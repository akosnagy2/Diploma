%----------------------------------------------------------------------------
\chapter{Útvonaltervezés C*CS pályákkal}
%----------------------------------------------------------------------------
A C*CS és a $c\overline{c}S$ algoritmus Kiss Domokos munkája \cite{CCSTopologicalProp}. Az algoritmusok elsõdlegesen autószerû robotok számára terveznek pályát, de az így tervezett pálya egy differenciális robot számára is végrehajtható. Feladatom az algoritmus implementálása volt C++ nyelven, majd annak tesztelése szimulációs, illetve valós környezetben.
A fejezetet az algoritmus ismertetésével kezdem, majd kitérek az implementációs problémákra, és az elért eredményekre is.

%----------------------------------------------------------------------------
\section{Reeds-Shepp lokális pályák}
%----------------------------------------------------------------------------
Az anholonom rendszerek irányítása akadályoktól mentes környezetben is egy igen bonyolult feladat. Sok esetben nem adható meg általános algoritmus, csak néhány speciális rendszer esetén. Szerencsére ilyen rendszerek közé tartoznak a differenciális robotok, az autószerû robotok, amelyek csak elõre mozoghatnak (Dubins autó), és azok, amelyek elõre és hátra is képesek mozogni.

\begin{figure}[H]
\centering
\includegraphics[width=140mm, keepaspectratio]{figures/dubins-reeds-shepp.png}
\caption{Dubins és Reeds-Shepp megoldások \cite{LaValle2}} 
\label{fig:reeds_shepp}
\end{figure}

Az utóbbi típusú robotokat hívjuk Reeds-Shepp autóknak, melyeknél bizonyított, hogy bármely kezdõ- és célkonfiguráció közt a legrövidebb utat megtalálhatjuk 48 lehetséges megoldás közül, amelybõl kettõ látható \aref{fig:reeds_shepp} ábrán. Ezek a lehetséges megoldások maximum öt egyenes vagy minimális sugarú körív kombinációjából állhatnak, és a pályák maximum két csúcsot tartalmazhatnak, azaz ennyiszer lehet irányt változtatni a végrehajtás közben \cite{ReedsShepp}.

Mint látható, akadályoktól mentes környezetben találhatunk optimális útvonalat, de ennek hátránya, hogy mindig minimális sugarú pályákat feltételez, mely egy valós esetben nem életszerû, illetve a pályák lehetnek igen bonyolultak is. Azonban ha elvetjük az optimalitás igényét -- amit egyébként is meg kell tennünk, ha egy globális tervezõ részeként alkalmazzuk a módszert -- akkor a lehetséges megoldásokon jelentõs mértékben egyszerûsíthetünk.

%----------------------------------------------------------------------------
\section{C*CS lokális pályák}\label{CCSlocal}
%----------------------------------------------------------------------------
A lokális tervezõk bármely kezdõ- és célkonfiguráció páros esetén megoldást kell nyújtsanak, de megfelelõ koordináta-rendszer választásával egyszerûsíthetünk a számításokon. Tegyük fel, hogy egy ilyen választás mellett adódott $q_{I} = (x_{I},y_{I},\theta_{I})$ kezdõ és $q_{G} = (0,0,0)$ célkonfiguráció. Ha eltekintünk a minimális fordulási sugár korlátozásától, és feltesszük, hogy $\theta_{I} \neq 0$, akkor könnyen belátható, hogy egy kör és egy egyenes segítségével elérhetõ a célkonfiguráció. Elõször egy érintõ körön elfordulunk a $\tilde{q_{G}} = (\tilde{x_{G}},0,0)$ köztes célkonfigurációba, majd egy egyenes mentén végighaladunk a célig. Az ehhez tartozó kör sugarát a következõ egyenlet segítségével számíthatjuk:

\begin{align}\label{eq:middleRadius}
\rho_{I,\tilde{G}} = \frac{y_{I}}{1 - \cos \theta_{I}}
\end{align}

Ha a kiadódó sugár kisebb, mint a minimálisan megengedett $|\rho_{I,\tilde{G}}| < \rho_{min}$, esetleg $\theta_{I} = 0$, akkor egy egyenes vagy egy kör segítségével egy köztes kezdõkonfigurációba ($\tilde{q_{I}} = (\tilde{x_{I}},\tilde{y_{I}},\tilde{\theta_{I}})$) kell eljutnunk, ahol biztosított, hogy $\tilde{\theta_{I}} \neq 0$ és, hogy $\rho_{\tilde{I},\tilde{G}} \geq \rho_{min}$. Megjegyzendõ, hogy az elsõ szakasz nem lehet egyenes, ha $\theta_{I} = 0$, $\theta_{I} = \pi$ vagy $|y_{I}| < 2\rho_{min}$. 

\begin{figure}[H]
\centering
\includegraphics[height=65mm, keepaspectratio]{figures/CCS.pdf}
\caption{A köztes konfiguráció megválasztása ($q_I'$) } 
\label{fig:infCCS}
\end{figure}

Bebizonyítható \cite{CCSTopologicalProp}, hogy $\tilde{q_I}$ köztes konfigurációt végtelen sokféleképpen megválaszthatjuk. A \figref{infCCS} ábrán látható erre egy példa. A $q_I$ kezdeti konfiguráció túl közel található a $q_G$ egyeneséhez, ezért elõbb egy köríven ($C^*$) el kell mozdulnunk egy köztes konfigurációba. Ezt megtehetjük elõrehaladással vagy tolatással is.

Hogy egyszerûsítsük a jelöléseket, a továbbiakban az egyenes szakaszokra $S$, a körívekre pedig a $C$ betûk segítségével hivatkozunk. Ezt felhasználva belátható, hogy a célpontba egy $SCS$, vagy egy $CCS$ pálya segítségével eljuthatunk. Könnyen belátható, hogy ha egy körív ($C$) sugarával a végtelenbe tartunk, akkor a szakasz az egyeneshez tart. Az olyan speciális köríveket, amelyek sugara végtelen is lehet, $C^{*}$-gal jelöljük. Innen a módszer neve, a $C^{*}CS$.

%----------------------------------------------------------------------------
\section{Globális tervezõ}\label{sec:globalPlanner}
%----------------------------------------------------------------------------
Ugyan bármilyen globális tervezõ által nyújtott pályát alapul vehetünk, a C*CS lokális tervezõ alapötlete, hogy körívek segítségével egy egyenes szakaszra forduljunk rá. Így sokkal természetesebb megoldásokat eredményez olyan globális pályák használata, melyek egyenes szakaszokból állítják elõ az eredményt.

Erre a célra egy celladekompozíción alapuló algoritmust használtam, melynek lényege, hogy a szabad környezetet cellákra osztja. Az egyik legegyszerûbben használható és legtermészetesebb ilyen cella a háromszög. Sokszögek háromszög-felbontására több algoritmus is létezik, én a Fade2D algoritmusát használtam \cite{fade2d}. Az elkészült felbontásra láthatunk egy példát a \figref{ccs_triang} ábrán.

\begin{figure}[H]
	\centering
	\includegraphics[width=125mm, keepaspectratio]{figures/ccs_triang.png}
	\caption{Környezet háromszögekre bontása} 
	\label{fig:ccs_triang}
\end{figure}

Miután a felbontás elkészült egy gráfot alkotunk a következõképpen: Kiválogatjuk azokat a háromszögoldalakat, amelyek nem akadályhoz vagy a környezet határához tartoznak. Ezeknek az oldalaknak felezõpontjai fogják a gráf pontjait alkotni. A gráfban két olyan pont között veszünk fel élt ahol azok egy háromszöghöz tartoznak, ezzel biztosítva, hogy ezek a szakaszok ne metsszék egymást. A pontok közé beszúrjuk a kezdõ és célkonfiguráció pontjait, meghatározzuk, hogy ezek melyik cellában helyezkednek el, és összekötjük az ahhoz a cellához tartozó pontokkal.

Az így elkészített gráfban még vannak olyan élek, amiket a végsõ megoldásban nem alkalmazhatunk, mert vagy egy akadályhoz, vagy a pálya széléhet túl közel találhatóak. Hogy ezeket kiszûrjük, végig kell nézzük, hogy ezeken az autóval végig tudunk-e haladni ütközés nélkül. Az ütközésdetektálásról még késõbb szót ejtek. Fontos megemlíteni, hogy az ellenõrzés során csak az autó szélességét vesszük figyelembe, mivel az a célunk, hogy ezeken a szakaszokon egyenesen haladjon az autó.

A már végleges gráfban (\figref{ccs_graph} ábra) minden élhez a hozzá tartozó szakasz hosszát hozzárendeljük, ezek fogják jelenteni az él súlyát. Végül a gráfban egy keresõalgoritmus segítségével kiválasztjuk a legrövidebb utat. Ha a gráf nem összefüggõ az algoritmus hibával tér vissza, mivel a feladat nem megoldható. A kereséshez én a Dijkstra-algoritmust használtam \cite{BFS}, de bármilyen más algoritmust használhatnánk, mivel a fentebb látott módszerrel alkotott gráf jellemzõen nem lesz nagy méretû, ezért nem lesz jelentõs különbség a futási idõk között.

\begin{figure}[H]
	\centering
	\includegraphics[width=125mm, keepaspectratio]{figures/ccs_graph.png}
	\caption{A kialakított gráf} 
	\label{fig:ccs_graph}
\end{figure}

A végleges megoldáshoz (\figref{ccs_prepath} ábra) nekünk nem csak pontokra, hanem konfigurációkra van szükségünk, ezért a legrövidebb út pontjaihoz még orientációt kell rendeljünk. Ezt a következõképpen tesszük meg: Az kezdeti és célkonfiguráció pontjainál az elõre meghatározott orientációt alkalmazzuk. Köztes pontok esetén az aktuális és a következõ pont által meghatározott egyenes és x-tengellyel bezárt szög adja az orientációt. Ezt a \eqref{ori} alapján számolhatjuk ki:

\begin{align}\label{eq:ori}
\theta_i = \arctan \left( \frac{y_{i+1} - y_i}{x_{i+1} - x_i} \right),
\end{align}

ahol $x_i$ és $y_i$ az aktuális pont megfelelõ koordinátái.

A megoldásnak az elõnye, hogy nagyjából a szabad terület közepén alkot pályát, így ha az autó ezt követi, akkor bármilyen irányú manõverezésre lesz lehetõsége. Továbbá ez egy kombinatorikus eljárás, így véges idõn belül képes megmondani, hogy létezik-e megoldás. Hátránya, hogy a háromszögelés miatt csak sokszögekkel leírható akadályokkal képes dolgozni

\begin{figure}
	\centering
	\includegraphics[width=125mm, keepaspectratio]{figures/ccs_prepath.png}
	\caption{Az elkészült globális pálya} 
	\label{fig:ccs_prepath}
\end{figure}

%----------------------------------------------------------------------------
\section{C*CS approximációs módszer}
%----------------------------------------------------------------------------
Az így elkészült globális pályát természetesen a töréspontok miatt nem tudnánk lekövetni egy autóval, ezért közelítenünk kell olyan pályákkal amik már nem okoznak gondot az autó számára sem. Ezt a C*CS approximációs módszer segítségével tesszük meg. A módszer a nevét a benne alkalmazott lokális tervezõrõl kapta, a mûködését az \textbf{Algoritmus \ref{alg:ccsApprox}} mutatja be.

\begin{algorithm}
\floatname{algorithm}{Algoritmus}
\caption{C*CS approximáció}\label{alg:ccsApprox}
\begin{algorithmic}[1]
	\State $Q := [q_{Q,1} \cdots q_{Q,m}] = GlobalisTervezo(\mathcal{C}_{obs}, q_I, q_G)$
	\State $\lambda_{final} := 0, \quad i := 1, \quad j := m $
	\State $arm := ARM(\mathcal{C}_{obs}, q_I)$
	\While{$(j-i) <> 1$}
		\State $q_{IL} := q_{Q,i}, \quad q_{GL} := q_{Q,j}$
		\If{($\lambda_{local} := C^*CS(\mathcal{C}_{obs}, arm, q_{IL}, q_{GL})) <> 0$}
			\If{$q_{GL} = q_G$}
				\State $\lambda_{final} := $ Osszefuz($\lambda_{final}, \lambda_{local}$)
				\State \Return $\lambda_{final}$
			\Else
				\State $\lambda_{final} := $ Osszefuz($\lambda_{final}, \lambda_{local}^*$)
				\State $q_{Q,j} := q'_{GL}$
				\State $i := j, \quad j := m$
				\State $arm := ARM(\mathcal{C}_{obs}, q_{Q,i})$
			\EndIf
		\Else
			\State $j:= \lceil \frac{j-i}{2} \rceil + i $
		\EndIf
	\EndWhile
	\State \Return HIBA
\end{algorithmic}
\end{algorithm}

Mielõtt bemutatnám a mûködését, érdemes szót ejteni a jelölésekrõl. A globális tervezõ által elkészített konfigurációs listát $Q$ jelöli, ezen belül az $i$. konfigurációt $q_{Q,i}$. A környezet leírására a $\mathcal{C}_{obs}$ jelölést használtam. $\lambda$ jelöli az elkészült pályát, ahol alsó indexben a \emph{final} a teljes, míg a \emph{local} jelzõ a lokális tervezõ által készített pályára utal. A $q_I$ és $q_G$ a globálisan meghatározott kezdõ- és célkonfiguráció, míg a $q_{IL}$ és $q_{GL}$ a lokálisan közelíteni kívánt pályarészlethez tartozik.

\subsection{Mûködés}
Mint látható a globális pályát iterálva próbáljuk meg C*CS pályákkal közelíteni. Az elsõ lépésben rögtön a kezdõ és célkonfigurációval kezdve. Ha ez nem sikerül a 17. sorban látott módon, a pályát megfelezzük és a lokális célkonfigurációnak a középsõ töréspontot választjuk. Ezt egészen addig folytatjuk, míg nem találunk megoldást, vagy el nem fogynak az újabb köztes töréspontok. Az elõnye ennek a módszernek, hogy szerencsés esetben akár rögtön az elsõ iterációban is találhatunk pályát, ami jelentõsen felgyorsíthatja a mûködést.

Egyik fontos tulajdonsága az algoritmusnak, hogy nem kényszeríti az elkészült pályát a globális sarokpontokba, mivel nem igazán fontos számunkra, hogy elérjük õket\footnote{Nem is mindig elõnyös az utolsó egyenes szakasz használata, gondoljuk például arra az esetre, mikor az érintési pont a célkonfiguráció után található, ebben az esetben felesleges tolatások jelennének meg a pályában}. Elég csak a globális pályaszakaszokhoz ''tapadni``, ezért a megtalált pályából ilyenkor elhagyjuk az egyenes szakaszt, és csak a $C^*C$ részletet fûzzük hozzá a végleges pályához. Az újabb szakasz keresését az érintési pontból indítjuk, így ezt be kell szúrjuk a listába.

Egyetlen kivétel ez alól, mikor a lokális célkonfiguráció $q_{GL}$, az maga a globális célpont $q_G$. Ebben az esetben az utolsó szakaszt mindenképp hozzá kell fûzzük a végleges pályához, hogy elérjük a célpontot\footnote{Fontos megemlíteni, hogy a lokális tervezõ mindig elvégzi a számításokat a teljes $C^*CS$ pályára (ütközésdetektálás, legrövidebb út keresés), az utolsó $S$ szakasz késõbb kerül kitörlésre.}.

\begin{figure}[H]
\centering
\includegraphics[width=125mm, keepaspectratio]{figures/CS.pdf}
\caption{Középsõ körív számítása érintõ körrel} 
\label{fig:erintoKor}
\end{figure}

\subsection{Lokális tervezõ}
Az elõzõekben láthattuk, hogy a C*CS végtelen sok megoldást nyújt. Lokális esetben ez nem feltétlen hasznos, de akadályok jelenlétében már igen, mivel így sokkal nagyobb valószínûséggel találhatunk végrehajtható pályát. Természetesen az összes megoldást nincs lehetõségünk kipróbálni, így \mbox{$\tilde{q_I}$-t} valamilyen mintavételezõ eljárással kell kiválasztanunk. Sokféle mintavételezési megoldást fel lehetne használni, de az egyszerûség kedvéért én egy egyszerû fixtávolságú mintavételezést használtam.

\begin{figure}
\centering
\includegraphics[width=90mm, keepaspectratio]{figures/ARM.pdf}
\caption{Példa a körívekkel elérhetõ sokaságra (ARM)} 
\label{fig:ARM}
\end{figure}

A lokális tervezõ elsõ lépésben összegyûjti azokat a köríveket, amelyeket a robot megadott kezdõkonfigurációból ütközés mentesen el tud érni. Ezeknek a köríveknek a sokaságát \emph{Arc Reachable Manifold}-nak (ARM) nevezzük \cite{ARM}. Az összes ilyen \mbox{$\tilde{q_I}$-ból} az algoritmus megkeresi a célkonfigurációhoz tartozó érintõ körívet (\figref{erintoKor} ábra), és az egyenes szakaszt. Azokat a szegmenseket amelyek ütközés mentesen végrehajthatóak, összegyûjti egy listába, majd ebbõl a listából kikeresi azt, amelyik a legrövidebb az összes közül.

Itt érdemes megemlíteni, hogy a végeredmény akkor fog igazán hasonlítani a valósághoz, ha lecsökkentjük a tolatások számát, mivel az emberek nagy többsége nem szeret tolatva közlekedni. Ahhoz, hogy ezt megtegyük, az algoritmus figyelembe vesz egy súlytényezõt, mellyel a tolató szakaszok ``hosszát'' tudjuk megnövelni.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/ccs_middle.png}
\caption{A C*CS algoritmus mûködés közben, második iterációra található lokális pálya.} 
\label{fig:CCSonline}
\end{figure}

%----------------------------------------------------------------------------
\section{ \texorpdfstring{\boldmath{$c\overline{c}S$}}{ccS} lokális tervezõ algoritmus }
%----------------------------------------------------------------------------
Az approximációs algoritmus nem teljes ebben a formájában, mivel ha nem talál újabb töréspontot, akkor hibával tér vissza. Megtehetnénk, hogy az egyenes szakaszokat feldaraboljuk, de ezzel nem nyernék új megoldásokat, mivel minden esetben ugyan arra az $S$ szakaszra próbálnánk érintõt találni. Ezért az új konfigurációkat a töréspontokban kell elhelyezni. Viszont önmagában ez még nem elég, valahogy biztosítanunk kell azt, hogy az algoritmus konvergáljon a megoldás felé.

\subsection{Topológiai feltétel}

Olyan lokális tervezõre van szükségünk, mely teljesíti az úgynevezett topológiai feltételt. Ha ezt biztosítani tudjuk, akkor az approximációs algoritmusunk teljes lesz. A teljesség itt azt jelenti, hogy az algoritmus minden olyan esetben megoldással tér vissza, mikor a globális tervezõ érvényes pályát szolgáltatott. Tehát a körívekkel való közelítés nem csökkenti a megoldás létezésének esélyét.

Egy lokális tervezõ (szakirodalomban \emph{steering method}) Steer($q_0$,$q_1$) teljesíti a topológiai feltételt, ha:

\begin{align}\label{eq:topologicalProp}
\forall \epsilon > 0, \quad \exists \eta > 0, \quad \forall q_0,q_1 \in \mathcal{C} \\ \notag
d_{\mathcal{C}}(q_0,q_1) < \eta \Rightarrow d_{\mathcal{C}} \Big( q_{0}, Steer(q_{0},q_{1}) (\sigma) \Big) < \epsilon, \\ \notag
\forall \sigma \in [q,S],
\end{align}

ahol $d_{\mathcal{C}}$ egy bármilyen metrika $\mathcal{C}$ konfigurációs téren definiálva.

\begin{figure}[H]
\centering
\includegraphics[height=60mm, keepaspectratio]{figures/topProp.png}
\caption{Topológiai feltétel illusztrációja $\mathcal{C} = \mathbb{R}^2$ esetén \cite{CCSTopologicalProp}} 
\label{fig:topProp}
\end{figure}

Ez azt jelenti, hogy ha bármilyen pozitív \mbox{$\epsilon$-hoz} található olyan $\eta$, hogy $q_1$ a $q_0$ -- $\eta$ környezetében van, akkor a lokális tervezõ által generált pálya nem lépi ki a $q_0$ -- $\epsilon$ környezetét. Erre egy segítõ példa a \figref{topProp} ábrán látható.

Más szavakkal tehát, ha a globális pályát közelítjük a $q_0$ konfigurációs pontból, amelynek van egy $\epsilon$ sugarú, ütközésmentes környezete, akkor találhatunk olyan $q_1$ konfigurációt, amelyre a lokális tervezõnk ütközésmentes és végrehajtható pályát eredményez. Ez azt is magával vonja, hogy ha a globális pálya mellett van egy kis szabad terület ahol manõverezésre van lehetõség, akkor a lokális tervezõ talál megoldást.

\subsection{ \texorpdfstring{\boldmath{$c\overline{c}S$}}{ccS} }
Bizonyított, hogy a $c\overline{c}S$ algoritmus teljesíti ezt a feltételt \cite{CCSTopologicalProp}, tehát felhasználható a konfigurációk közelítésekor. Ezek alapján az approximációs algoritmust kiegészíthetjük a következõkkel: Ha nincs új sarokpont a globális pályán, akkor egy egyenes szakasz segítségével elmegyünk a következõ sarokpontig. Ezt megtehetjük, mivel ez biztosan ütközésmentes, csak elhagytuk a pályából. Majd a globális pályába beszúrunk egy konfigurációt, ahol a pont a következõ sarokpont, és az orientáció az aktuális sarokponthoz tartozó szög. Végül ezek között keresünk megoldást, de már az új -- topológiai feltételt biztosító -- lokális tervezõvel. Ha ezek között sincs végrehajtható pálya, akkor a konfigurációs térben ($\mathcal{C}$) távolságot csökkentenünk kell. Ezt az orientációkülönbség megfelezésével megtehetjük.

\begin{figure}[H]
\centering
\includegraphics[width=140mm, keepaspectratio]{figures/cc_S.png}
\caption{A $c\overline{c}S$ algoritmus megoldásai különbözõ $y_{I}$ esetén\cite{CCSTopologicalProp}} 
\label{fig:cc_S}
\end{figure}

A $c\overline{c}S$ algoritmusra a $C^*CS$ algoritmus egy módosított változata, mely csak egy megoldást ad egy konfiguráció párra. Az eljárás lényege, hogy az elsõ két kör sugara minimális és megegyezõ, de ellentétes elõjelû, tehát a másik irányba kell forgassuk a kormányt. A komplementer jelölés jelzi az elõjel változását. Ahogy \aref{fig:cc_S} ábrán látható, ha $q_{I}$ túl közel van a $q_{G}$ egyeneséhez, akkor a körök egymás mellett elcsúsznak, és két megoldást is adnak.

Bár a $c\overline{c}S$ definíció szerint egy megoldást ad, a végrehajtásakor több pályát is ``eldob''. A módszer implementációját úgy készítettem el, hogy minden ilyen megoldást ellenõrizzen, ha esetleg a legrövidebb nem lenne végrehajtható, akkor válasszon másikat. Jogosan felmerülhet a kérdés, hogy ha ez az algoritmus minden esetben nyújt megoldást, akkor miért nem ezt használjuk a C*CS helyett? Bár valóban igaz, a $c\overline{c}S$ mindig használható, a C*CS több lehetséges megoldás közül választ, így a gyakorlatban természetesebb pályákat ad eredményül.

%----------------------------------------------------------------------------
\section{Ütközésdetektálás}
%----------------------------------------------------------------------------
Akadályok jelenlétében nem kerülhetõ el a tervezett pálya végrehajthatóságának vizsgálata. Azért is fontos ezt megemlíteni, mert a tervezés során ennek a számítása az egyik leginkább idõigényes folyamat. Általános esetben ez a probléma igen bonyolult, és még inkább idõigényes folyamattá is válhat.

Abban az esetben, ha mind az akadályok, mind a robot teste sokszögekkel leírható, de a tervezett pályával kapcsolatban nincsen semmilyen megkötésünk, csak a mintavételezésre hagyatkozhatunk. Az elkészült pályát fel kell osztani több pontra, és ezeken a helyeken ellenõrizni, hogy a robot teste nem ér-e ki a pályáról vagy lóg-e bele az egyik akadályba. Ilyenkor különös odafigyeléssel kell megválasztanunk a mintavételezõ eljárást, mivel ha túl távoli pontokat ellenõrzünk, lehet, hogy kihagyunk olyan pontokat, amelyek ütköznének. Túlságosan sûrû mintavételezéssel pedig az eljárás mûködése lelassul.

Az általam használt algoritmusoknál nincs szükség mintavételezésre, mivel az elkészült pályák (körívek, és egyenes szakaszok) zárt alakban felírhatók. Az ütközésdetektáláshoz a robot testét a meghatározott pályán kell végigmozgatni, és ellenõrizni, hogy egyik pontjának pályája se keresztezi bármelyik akadály élét\footnote{Ebben az esetben a pálya széle is akadályként tekinthetõ.}.

\subsection*{Egyenes szakaszok}
Egyenes szakaszok ütközésdetektálását két különbözõ módon oldottam meg. A globális tervezõ esetén csak az akadályok és a lehetséges pályaszakaszok távolságát számítja ki az algoritmus. Elõször is ellenõri, hogy a két szakasz metszi-e egymást. Ha igen, a távolságuk nulla. Ha nem, akkor minden szakasz két végpontját levetíti az ellenõrizni kívánt szakaszra. Ha ez a vetületi pont a szakaszon belül található, akkor ennek és a végpontnak a távolságát vesszük eredményül, ha kívülre esik, akkor a két végpont távolsága az eredmény (\figref{segDist}). Ha a szakaszok távolsága kisebb mint a robot maximális szélességének a fele, akkor az élt törüljük.

\begin{figure}[H]
\centering
\includegraphics[height=35mm, keepaspectratio]{figures/segDist.pdf}
\caption{Szakaszok távolságának meghatározása} 
\label{fig:segDist}
\end{figure}

Természetesen ez nem vezet pontos eredményre, de \aref{sec:globalPlanner} fejezetben ezt a hibát figyelmen kívül hagyjuk. A másik, pontosabb módszert detektáláshoz a körívek esetén mutatom be.

\subsection*{Körívek}
Mivel kikötöttük, hogy a robotunk teste is sokszögekkel leírható az ellenõrzéséhez elegendõ a csúcsokat elmozdítani a pályával párhuzamosan. Ezt mind egyenes szakaszok, mind körívek esetén hasonlóan kell megtegyük. Kiválasztunk egy csúcsot, majd egy koordinátatranszformáció segítségével a pálya végpontjait eltoljuk a megfelelõ helyre, azaz kiszámoljuk, hogy a két végpontban a robot azon pontja hol is lesz pontosan. Egyenes szakaszoknál ez a két pont meghatározza az új szakaszt, körív esetén a két új pont és a pálya körének középpontja segítségével kiszámítjuk az új körívet. Amint ezzel készen vagyunk, metszéspontot keresünk az áttranszformált pálya, és az akadályélek között. Ez körív és egyenes esetén egy kicsit komplikáltabb feladat, mivel itt a megoldást egy másodfokú egyenlet határozza meg.

\begin{figure}[H]
\centering
\includegraphics[height=75mm, keepaspectratio]{figures/collDetect.pdf}
\caption{Hibás ütközésdetektálás, nem elég csak a robot pontjait mozgatni} 
\label{fig:collDetect}
\end{figure}

Ha ezt megtettük, még nem vagyok készen, le kell ellenõriznünk a fordított esetet is, amikor az akadályok csúcsait mozgatjuk a pályán, de ellentétes irányban. Erre azért van szükség, mert elképzelhetõ olyan helyzet, hogy a robot sarokpontjai ugyan nem metszenek egyetlen akadályélt se, mégis ütközünk akadállyal. Erre láthatunk egy példát a \figref{collDetect} ábrán.

Ezt úgy tehetjük meg, hogy kiszámítjuk a pálya végpontjából az akadály egyik csúcsába mutató vektort, majd ezt használjuk fel a kezdõpont transzformálásához. Az így keletkezett pontot és a csúcspontot a pályának megfelelõ szakasszal összekötjük, és ellenõrizzük, hogy a robot testének éleivel van-e metszéspontja. Ha egyik esetben se volt metszet, akkor a pálya végrehajtható.

%----------------------------------------------------------------------------
\section{Eredmények}
%----------------------------------------------------------------------------
A feladatom megvalósításához rendelkezésre állt a C*CS algoritmus egy MATLAB scriptben megírt változata, ellenben ez csak demonstrációs célokat szolgált, a feladatot lassan hajtotta végre, valószínûleg az interpretált mûködés következtében, ezért vált szükségessé egy C++ implementáció.

Az így készült programmal nagyságrendileg százszoros gyorsulást sikerült elérnem, és a legbonyolultabb környezetben is egy másodpercen belül sikerült megoldást találnia az algoritmusnak\footnote{Intel Core 2 Duo E8400 @ 3.0GHz, 4GB RAM}. Ez egy igen nagy elõrelépés, így valószínû, hogy egy kisebb teljesítményû beágyazott számítógépen is elfogadható idõn belül végez.

\begin{figure}[H]
\centering
\includegraphics[height=65mm, keepaspectratio]{figures/frame3.png}
\includegraphics[height=65mm, keepaspectratio]{figures/frame6.png}
\caption{A C*CS algoritmus megoldása különféle környezetekben} 
\label{fig:ccssolutions}
\end{figure}

\subsection{Fejlesztési lehetõségek}
A fejlesztés során odafigyeltem, hogy hol lehetne gyorsítani, módosítani a mûködésen. Ahol ez egyszerûen megvalósítható volt, ott ezeket megtettem, de maradtak további fejlesztési lehetõségek is a programban, például számos helyen lehetne a futást párhuzamosítani.

A tapasztalatok azt mutatták, hogy az algoritmus futásának jelentõs hányada az ARM számítása. Mivel a körívek kiszámítása, és azok ütközésdetektálása komplex mûvelet, így ez az eredmény nem meglepõ. A kiszámítás ideje természetesen függ a választott távolságegységtõl és a környezet méretétõl. A számítást fel lehet gyorsítani, ha a mintavételezésnél használt távolságot megnöveljük, de ezzel lehetséges megoldásokat hagyhatunk el.

Másik javítási lehetõség, ha elõre elkészítünk egy foglaltsági mátrixot, ami megmondja az adott pont akadályon beül van-e, így ezekre a pontokra nem kell a számítást elvégezni. Mivel az így kapott körívek egy adott kezdõkonfigurációhoz tartoznak, további gyorsításra ad lehetõséget, ha az approximációs lépésben inkább a célkonfiguráció pontját mozgatjuk, így nem kell újra és újra kiszámolni az ARM-ot. Az \textbf{Algoritmus \ref{alg:ccsApprox}} esetén is ez látható. A harmadik sorban rögtön a kezdõ konfigurációra elvégezzük a számítást, és csak akkor ismételjük meg újra, ha a kezdõpontunk is megváltozott (14. sor).

%----------------------------------------------------------------------------
\section{Új globális tervezõ}
%----------------------------------------------------------------------------
Az esetek nagy többségében \aref{sec:globalPlanner} fejezetben használt celladekompozíciós eljárás jó eredménnyel szolgál, de több problémával is rendelkezik. Például könnyen észrevehetõ, hogy az egyszerû ütközésdetektálásnál még maradhatnak olyan élek a gráfban, melyek nem minden esetben végrehajthatóak.

További hibát okoz, hogy nem ellenõrzi az eljárás, hogy van-e hely manõverezésre, pedig ez a topológiai feltételnél látható, hogy ez a végrehajtható pálya megtalálásának feltétele. Ez a probléma jelentkezik két merõleges folyosónál is. Hiába a felhasznált szakaszok távolsága mindkét folyosón nagyobb, mint az autó szélessége, nincs hely a megfordulásra.

\begin{figure}[H]
\centering
\includegraphics[width=70mm, keepaspectratio]{figures/alley.pdf}
\includegraphics[width=70mm, keepaspectratio]{figures/paralell.pdf}
\caption{Hibás globális pályák. A bal oldalon merõleges folyosók problémája, ahol nincs lehetõség elfordulni. Jobb oldalon a párhuzamos parkolás problémája, a piros konfigurációk okozzák a bonyolult pályát.} 
\label{fig:globalError}
\end{figure}

Egy másik problémás tulajdonsága az orientációk meghatározásakor jelentkezik. Mivel a kiindulási és célkonfiguráció esetén az elõre meghatározott orientációkat használjuk, a köztes sarokpontoknál pedig a pálya segítségével határozzuk meg, így kialakulhatnak ellentmondásos (egymással szembe mutató) konfigurációk. Ez jelentkezik párhuzamos parkolás esetén is. Ugyan ilyen esetben található megoldás, de a keletkezett útvonal túl bonyolult lesz, így a valóságban ez használhatatlanná válik.

A fejlesztés során a fentebb felsorolt problémák miatt a globális tervezõt lecseréltem az RTR nevû algoritmusra. Ez is Kiss Domokos munkája \cite{DomiRTR}, az implementációját Nagy Ákos végezte el \cite{Akos}. Ez egy, a szakirodalomban széles körben használt RRT (Rapidly Exploring Random Trees) módszeren alapuló pályatervezési eljárás.

\subsection{RRT}
A globális tervezõk sok esetben topologikus gráfokat (speciális esetben fákat) használnak a konfigurációs tér struktúrájának leírásához \cite{kavraki96prm}. A szakirodalomban egyik leggyakrabban használt ilyen algoritmus a \emph{Rapidly Exploring Random Trees} \cite{LaValle}. Ennek a lényege, hogy a kezdeti konfigurációból egy fát építünk a szabadon bejárható konfigurációs térben. A fa csomópontjaiban konfigurációk találhatóak, és a fa terjesztését úgy irányítjuk, hogy a kívánt célkonfiguráció felé tartson. Ha a fa ténylegesen eléri a célkonfigurációt, akkor az utat a kezdeti konfigurációból a célkonfigurációba már könnyedén megkaphatjuk.

\begin{figure}[H]
\centering
\includegraphics[width=145mm, keepaspectratio]{figures/RRT.png}
\caption{Az RRT algoritmus három különbözõ iterációnál \cite{LaValle}.} 
\label{fig:RRT}
\end{figure}

A fák építését három fázisra lehet felbontani. Az elsõ fázisban véletlenszerûen kiválasztunk a szabad konfigurációs térbõl egy pontot ($q_{rand}$). Ezt nevezzük \emph{mintavételezési fázisnak}. Majd végighaladunk a fán, és kiválasztjuk, melyik konfiguráció található legközelebb a mintavételezett ponthoz ($q_{near}$). Ezt a \emph{csomópont kiválasztó szakasznak} nevezzük. Majd végül megpróbáljuk a $q_{rand}$ és $q_{near}$ konfigurációkat összekötni (\emph{összekötési fázis}).

Az utolsó fázisban általában egy elõre meghatározott hosszakig veszünk fel szakaszokat. Anhonolóm rendszerek esetén is lehet használni az RRT algoritmust, ilyenkor az összekötési fázisban egy lokális tervezõt kell használnunk. Természetesen több fát is terjeszthetünk egyszerre, ilyenkor az összes fa esetén végre kell hajtani a fázisokat. A terjesztést addig folytatjuk, mígya fák össze nem kapcsolódnak.

\subsection{RTR}
Az \emph{Rotate-Translate-Rotate} algoritmus a fentebb látott RRT algoritmus egy módosított változata. Elsõdlegesen differenciális robotok számára tervez egyenes szakaszokból és egy helyben fordulásokból álló pályát, de jó alapot szolgáltat a C*CS algoritmushoz is. Nevét a benne használt mozgási lokális tervezõrõl kapta, azaz a $R$, mint fordulás, a $T$ pedig az egyenesen haladást jelöli. Az eljárás az RRT mindhárom fázisában vezet be változásokat, és mind a kezdõ, mind a célkonfigurációból növesztünk fákat.

\begin{figure}[H]
\centering
\includegraphics[width=90mm, keepaspectratio]{figures/rtr_rci.png}
\caption{A kiterjesztés folyamata. \cite{Akos}}
\label{fig:rtr_rci}
\end{figure}

\begin{itemize}
	\item A mintavételezés során nem csak egy konfigurációt választunk, hanem egy pozíciót a térben ($p_G$), és az ehhez tartozó konfigurációs térbeli egyenes bármely pontja felé növesztjük tovább a fákat.
	\item A kiválasztási fázisban egyszerûbb a dolgunk, mivel csak egy pozícióhoz képest kell figyeljük a távolságokat. Itt figyelembe kell vegyük a szögek távolságát is.
	\item A kiterjesztés fázisa különbözik leginkább az RRT-ben látottaktól. Itt nem csak a $p_G$ felé terjesztjük a fákat, hanem ellentétes irányban is. Illetve nem csak a pontig, hanem minden esetben addig, míg nem ütközik egy akadályba a robot. Ha a forgás közben ütközik a robot, akkor az ütközési pontból is továbbterjesztünk. Erre látható egy példa a \figref{rtr_rci} ábrán.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=110mm, keepaspectratio]{figures/rtr_path2.pdf}
\caption{Az RTR algoritmus; piros a kezdõ, kék a célkonfigurációból indított fa. \cite{Akos}}
\label{fig:rtr_path2}
\end{figure}

Ez az algoritmus azért elõnyös, mert a celladekompozíciós eljárás hibáját kiküszöböli. Tehát két szûk folyosó találkozásánál csak akkor ad megoldást, ha van hely az elfordulásra. Mivel a keresés során két fát épít, így a párhuzamos parkolás esetén is segíti a megoldás megtalálását.