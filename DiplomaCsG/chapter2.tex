%----------------------------------------------------------------------------
\chapter{Útvonaltervezés C*CS pályákkal}
%----------------------------------------------------------------------------
A C*CS és a $c\overline{c}S$ algoritmus Kiss Domokos munkája \cite{CCSTopologicalProp}. Az algoritmusok elsõdlegesen autószerû robotok számára terveznek pályát, de az így tervezett pálya egy differenciális robot számára is végrehajtható. Feladatom az algoritmus implementálása volt C++ nyelven, majd annak tesztelése szimulációs, illetve valós környezetben.
A fejezetet az algoritmus ismertetésével kezdem, majd kitérek az implementációs problémákra, és az elért eredményekre is.

%----------------------------------------------------------------------------
\section{Reeds-Shepp lokális pályák}
%----------------------------------------------------------------------------
Az anholonom rendszerek irányítása akadályoktól mentes környezetben is egy igen bonyolult feladat. Sok esetben nem adható meg általános algoritmus, csak néhány speciális rendszer esetén. Szerencsére ilyen rendszerek közé tartoznak a differenciális robotok, az autószerû robotok, amelyek csak elõre mozoghatnak (Dubins autó), és azok, amelyek elõre és hátra is képesek mozogni.

\begin{figure}[H]
\centering
\includegraphics[width=140mm, keepaspectratio]{figures/dubins-reeds-shepp.png}
\caption{Dubins és Reeds-Shepp megoldások \cite{LaValle2}} 
\label{fig:reeds_shepp}
\end{figure}

Az utóbbi típusú robotokat hívjuk Reeds-Shepp autóknak, melyeknél bizonyított, hogy bármely kezdõ- és célkonfiguráció közt a legrövidebb utat megtalálhatjuk 48 lehetséges megoldás közül, amelybõl kettõ látható \aref{fig:reeds_shepp} ábrán. Ezek a lehetséges megoldások maximum öt egyenes vagy minimális sugarú körív kombinációjából állhatnak, és a pályák maximum két csúcsot tartalmazhatnak, azaz ennyiszer lehet irányt változtatni a végrehajtás közben \cite{ReedsShepp}.

Mint látható, akadályoktól mentes környezetben találhatunk optimális útvonalat, de ennek hátránya, hogy mindig minimális sugarú pályákat feltételez, mely egy valós esetben nem életszerû, illetve a pályák lehetnek igen bonyolultak is. Azonban ha elvetjük az optimalitás igényét -- amit egyébként is meg kell tennünk, ha egy globális tervezõ részeként alkalmazzuk a módszert -- akkor a lehetséges megoldásokon jelentõs mértékben egyszerûsíthetünk.

%----------------------------------------------------------------------------
\section{C*CS lokális pályák}\label{CCSlocal}
%----------------------------------------------------------------------------
A lokális tervezõk bármely kezdõ- és célkonfiguráció páros esetén megoldást kell nyújtsanak, de megfelelõ koordináta-rendszer választásával egyszerûsíthetünk a számításokon. Tegyük fel, hogy egy ilyen választás mellett adódott $q_{I} = (x_{I},y_{I},\theta_{I})$ kezdõ és $q_{G} = (0,0,0)$ célkonfiguráció. Ha eltekintünk a minimális fordulási sugár korlátozásától, és feltesszük, hogy $\theta_{I} \neq 0$, akkor könnyen belátható, hogy egy kör és egy egyenes segítségével elérhetõ a célkonfiguráció. Elõször egy érintõ körön elfordulunk a $\tilde{q_{G}} = (\tilde{x_{G}},0,0)$ köztes célkonfigurációba, majd egy egyenes mentén végighaladunk a célig. Az ehhez tartozó kör sugarát a következõ egyenlet segítségével számíthatjuk:

\begin{align}\label{eq:middleRadius}
\rho_{I,\tilde{G}} = \frac{y_{I}}{1 - \cos \theta_{I}}
\end{align}

Ha a kiadódó sugár kisebb, mint a minimálisan megengedett ($|\rho_{I,\tilde{G}}| < \rho_{min}$), esetleg $\theta_{I} = 0$, akkor egy egyenes vagy egy kör segítségével egy köztes kezdõkonfigurációba ($\tilde{q_{I}} = (\tilde{x_{I}},\tilde{y_{I}},\tilde{\theta_{I}})$) kell eljutnunk, ahol biztosított, hogy $\tilde{\theta_{I}} \neq 0$ és, hogy $\rho_{\tilde{I},\tilde{G}} \geq \rho_{min}$. Megjegyzendõ, hogy az elsõ szakasz nem lehet egyenes, ha $\theta_{I} = 0$, $\theta_{I} = \pi$ vagy $|y_{I}| < 2\rho_{min}$. Bebizonyítható \cite{CCSTopologicalProp}, hogy $\tilde{q_I}$ köztes konfigurációt végtelen sokféleképpen megválaszthatjuk.

\begin{figure}[H]
\centering
\includegraphics[height=65mm, keepaspectratio]{figures/CCS.pdf}
\caption{$\tilde{q_I}$ megválasztása } 
\label{fig:infCCS}
\end{figure}

Hogy egyszerûsítsük a jelöléseket, a továbbiakban az egyenes szakaszokra $S$, a körívekre pedig a $C$ betûk segítségével hivatkozunk. Ezt felhasználva belátható, hogy a célpontba egy $SCS$, vagy egy $CCS$ pálya segítségével eljuthatunk. Könnyen belátható, hogy ha egy körív ($C$) sugarával a végtelenbe tartunk, akkor a szakasz az egyeneshez tart. Az olyan speciális köríveket, amelyek sugara végtelen is lehet, $C^{*}$-gal jelöljük. Innen a módszer neve, a $C^{*}CS$.

%----------------------------------------------------------------------------
\section{Globális tervezõ}
%----------------------------------------------------------------------------
Ugyan bármilyen globális tervezõ által nyújtott pályát alapul vehetünk, a C*CS lokális tervezõ alapötlete, hogy körívek segítségével egy egyenes szakaszra forduljunk rá. Így sokkal természetesebb megoldásokat eredményez olyan globális pályák használata, melyek egyenes szakaszokból állítják elõ az eredményt.

Erre a célra egy celladekompozíción alapuló algoritmust használtam, melynek lényege, hogy a szabad környezetet cellákra osztja. Az egyik legegyszerûbben használható és legtermészetesebb ilyen cella a háromszög. Sokszögek háromszög-felbontására több algoritmus is létezik, én a Fade2D algoritmusát használtam \cite{fade2d}.

Miután a felbontás elkészült egy gráfot alkotunk a következõképpen: Kiválogatjuk azokat a háromszögoldalakat, amelyek nem akadályhoz vagy a környezet határához tartoznak. Ezeknek az oldalaknak felezõpontjai fogják a gráf pontjait alkotni. A gráfban két olyan pont között veszünk fel élt ahol azok egy háromszöghöz tartoznak, ezzel biztosítva, hogy ezek a szakaszok ne metsszék egymást. A pontok közé beszúrjuk a kezdõ és célkonfiguráció pontjait, meghatározzuk, hogy ezek melyik cellában helyezkednek el, és összekötjük az ahhoz a cellához tartozó pontokkal.

Az így elkészített gráfban még vannak olyan élek, amiket a végsõ megoldásban nem alkalmazhatunk, mert vagy egy akadályhoz, vagy a pálya széléhet túl közel találhatóak. Hogy ezeket kiszûrjük, végig kell nézzük, hogy ezeken az autóval végig tudunk-e haladni ütközés nélkül. Az ütközésdetektálásról még késõbb szót ejtek. Fontos megemlíteni, hogy az ellenõrzés során csak az autó szélességét vesszük figyelembe, mivel az a célunk, hogy ezeken a szakaszokon egyenesen haladjon az autó.

A már végleges gráfban minden élhez a hozzá tartozó szakasz hosszát hozzárendeljük, ezek fogják jelenteni az él súlyát. Végül a gráfban egy keresõalgoritmus segítségével kiválasztjuk a legrövidebb utat. Ha a gráf nem összefüggõ az algoritmus hibával tér vissza, mivel a feladat nem megoldható. A kereséshez én a Dijkstra-algoritmust használtam \cite{BFS}, de bármilyen más algoritmust használhatnánk, mivel a fentebb látott módszerrel alkotott gráf jellemzõen nem lesz nagy méretû, ezért nem lesz jelentõs különbség a futási idõk között.

A megoldásnak az elõnye, hogy nagyjából a szabad terület közepén alkot pályát, így ha az autó ezt követi, akkor bármilyen irányú manõverezésre lesz lehetõsége. Továbbá ez egy kombinatorikus eljárás, így véges idõn belül képes megmondani, hogy létezik-e megoldás. Hátránya, hogy a háromszögelés miatt csak sokszögekkel leírható akadályokkal képes dolgozni

\begin{figure}
	\centering
	\includegraphics[width=130mm, keepaspectratio]{figures/ccs_prepath.png}
	\caption{Elõzetes pálya tervezése, szürke háromszögek a szabad tér felbontását, pontozott vonal a gráfot, szaggatott vonal pedig az elkészült elõzetes pályát jelzi} 
	\label{fig:ccs_triang}
\end{figure}

%----------------------------------------------------------------------------
\section{C*CS approximációs módszer}
%----------------------------------------------------------------------------
Az általam használt algoritmus egy approximációs módszert alkot, mely egy elõzetes globális pályát rekurzív módon felbont kisebb szakaszokra, majd ezekre próbál illeszteni egy-egy fentebb bemutatott C*CS pályát.\footnote{Bár a lokális tervezõ algoritmus neve a C*CS, de a végeredményben kialakult pálya összességében is körök és egyenesek kombinációjából áll, így ez a név ráragadt az approximációs módszerre is.} A végeredményül elkészült, az algoritmus által visszaadott pálya autószerû robotokkal könnyedén lekövethetõ, mivel elsõdlegesen ezek számára lett kialakítva. Ennek ellenére a megoldást természetesen egy differenciális robot is képes lekövetni, mivel az nem rendelkezik korlátozással a forduló kör sugarát illetõen.

\begin{algorithm}[H]
\floatname{algorithm}{Algoritmus}
\caption{C*CS approximáció}\label{alg:ccsApprox}
\begin{algorithmic}
\State \Call{Func}{$asd$}
\end{algorithmic}
\end{algorithm}

\subsection{Lokális tervezõ alkalmazása}
Ha a globális tervezõ tudott visszaadni megoldást, akkor az algoritmus tovább folytatódik a következõképpen: Az elõzetes pálya két konfigurációját kiválasztjuk, és a fentebb említett C*CS pályákat keresünk köztük. Az eljárás elõször a pálya két végpontja közt keres útvonalat, ami egyszerû esetekben akár rögtön megoldásra is vezethet, felgyorsítva az algoritmus mûködését. Ha ez a keresés nem járt sikerrel, akkor az elõzetes pályát megfelezi az algoritmus, és az elsõ konfiguráció, valamint a félpályához legközelebb esõ sarokpontbeli konfiguráció közt keres megoldást. Ezt egészen addig ismétli, míg van köztes sarokpont a pályában. Ha elfogyott, további pontokat illeszt a pályába.

Az elõzõekben láthattuk, hogy a C*CS végtelen sok megoldást nyújt. Lokális esetben ez nem feltétlen hasznos, de akadályok jelenlétében már igen, mivel így sokkal nagyobb valószínûséggel találhatunk végrehajtható pályát. Természetesen az összes megoldást nincs lehetõségünk kipróbálni, így ezt a problémát valamilyen mintavételezõ eljárással kell megoldanunk.

A végtelen sok megoldást a $\tilde{q_{I}}$ kiválasztásának szabadsága okozza. Erre egy példa látható \aref{fig:infCCS} ábrán. Ezért az algoritmus összegyûjti azokat a konfigurációkat, melyeket a $q_{I}$ konfigurációból ütközés nélkül elérhetünk. Ehhez a környezetet fel kell osszuk egységnyi távolságokra, mivel így véges sok lehetõséget kapunk. A kiszámítás ideje természetesen függ a választott távolságegységtõl és a környezet méretétõl. Az eredmények azt mutatják, hogy a teljes algoritmus futásának ez a leghosszabb része, ami nem meglepõ, mivel a körívek kiszámítása komplex mûvelet, és ezt egy adott pont esetén a robot testének minden csúcsára ki kell számoljuk, hogy ütközést tudjunk detektálni. A mûvelet hatékonyságán több módon lehet javítani, például nagyobb távolságegység megválasztásával. Másik javítási lehetõség, ha elõre elkészítünk egy foglaltsági mátrixot, ami megmondja az adott pont akadályon beül van-e, így ezekre a pontokra nem kell a számítást elvégezni. Mivel az így kapott körívek egy adott kezdõkonfigurációhoz tartoznak, további gyorsításra ad lehetõséget, ha az approximációs lépésben inkább a célkonfiguráció pontját mozgatjuk, így nem kell újra és újra kiszámolni a köríven elérhetõ sokaságot.

\begin{figure}[H]
\centering
\includegraphics[width=90mm, keepaspectratio]{figures/CS.pdf}
\caption{Középsõ körív számítása érintõ körrel} 
\label{fig:erintoKor}
\end{figure}

Az algoritmus további részében \aref{CCSlocal} pontban említett módon, a hátralévõ körív, és egyenes szakasz kiszámítása a feladat. Egy irányított kör esetén ez két lehetséges pályát jelent, amint az látható \aref{fig:erintoKor} ábrán. Ezek után nem elég csak a körívek végrehajthatóságát ellenõriznünk, hanem meg kell nézzük ezt a hátralévõ egyenes szakaszokra is. Ugyan a globális pálya tervezésekor ellenõriztük ezeket, de az érintõ körök keresésekor nem volt feltétel, hogy az érintési pontok ezeken a szakaszokon belül helyezkedjenek el.

Végül az így keletkezõ végrehajtható pályák sokasága közül ki kell választanunk egyet. Ezt többféleképpen megtehetjük. Talán a legkézenfekvõbb a legrövidebb megoldás kikeresése és beillesztése az elõzetes pályába. Itt érdemes megemlíteni, hogy a végeredmény akkor fog igazán hasonlítani a valósághoz, ha lecsökkentjük a tolatások számát, mivel az emberek nagy többsége nem szeret tolatva közlekedni. Hogy ezt megtehessük, az algoritmus opcionálisan elfogad egy súlytényezõt, mellyel a tolató szakaszok ``hosszát'' tudjuk megnövelni.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/ccs_middle.png}
\caption{A C*CS algoritmus mûködés közben} 
\label{fig:CCSonline}
\end{figure}

%----------------------------------------------------------------------------
\section{ \texorpdfstring{\boldmath{$c\overline{c}S$}}{ccS} lokális tervezõ algoritmus }
%----------------------------------------------------------------------------
Ha az elõzõekben látottak nem vezetnek megoldásra, tehát nincs olyan C*CS pálya, mely végrehajtható lenne, akkor egy kisebb szakaszt kell választanunk a globális pályából. Ezt viszont nem tehetjük meg végtelenségig, mivel a globális pálya általában egyenes szakaszok együttesébõl áll. Ezek a szakaszok határozzák meg az $S$ szakasz egyenesét, így tovább bontani nincs értelme, mert nem változtatja meg a tervezett pályát. Ezért az új konfigurációkat a töréspontokban kell elhelyezni, viszont önmagában ez még nem biztosítja, hogy találunk megoldást. Valahogy biztosítanunk kell azt, hogy az algoritmusunk konvergáljon a megoldás felé, amihez olyan lokális tervezõre van szükségünk, mely teljesíti a lokális tervezõkre vonatkozó úgynevezett topológiai feltételt \cite{CCSTopologicalProp}. Ha ezt biztosítani tudjuk, akkor az approximációs algoritmusunk teljes lesz. A teljesség itt azt jelenti, hogy az algoritmus minden olyan esetben megoldással tér vissza, mikor a globális tervezõ érvényes pályát szolgáltatott. Tehát a körívekkel való közelítés nem csökkenti a megoldás létezésének esélyét.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/cc_S.png}
\caption{A $c\overline{c}S$ algoritmus megoldásai különbözõ $y_{I}$ esetén\cite{CCSTopologicalProp}} 
\label{fig:cc_S}
\end{figure}

Olyan esetekben, amikor a globális pályát tovább kellene bontanunk, átváltunk a $c\overline{c}S$ algoritmusra, mely a topológiai feltételt teljesíti. Ez az algoritmus a C*CS algoritmus egy módosított változata, mely csak egy megoldást ad egy konfiguráció párra. Az eljárás lényege, hogy az elsõ két kör sugara minimális és megegyezõ, de ellentétes elõjelû, tehát a másik irányba kell forgassuk a kormányt. A komplementer jelölés jelzi az elõjel változását. Ahogy \aref{fig:cc_S} ábrán látható, ha $q_{I}$ túl közel van a $q_{G}$ egyeneséhez, akkor a körök egymás mellett elcsúsznak, és két megoldást is adnak.

Bár a $c\overline{c}S$ egy megoldást ad, a végrehajtásakor több lehetséges megoldást is ``eldob''. A módszer implementációját úgy készítettem el, hogy minden ilyen megoldást ellenõrizzen, ha esetleg a legrövidebb nem lenne végrehajtható, akkor válasszon másikat. Jogosan felmerülhet a kérdés, hogy ha ez az algoritmus minden esetben nyújt megoldást, akkor miért nem ezt használjuk a C*CS helyett? Bár valóban a $c\overline{c}S$ mindig használható, a C*CS több lehetséges megoldás közül választ, így a gyakorlatban természetesebb pályákat ad eredményül.

%----------------------------------------------------------------------------
\section{Eredmények}
%----------------------------------------------------------------------------
A feladatom megvalósításához rendelkezésre állt a C*CS algoritmus egy MATLAB scriptben megírt változata, ellenben ez csak demonstrációs célokat szolgált, a feladatot lassan hajtotta végre, valószínûleg az interpretált mûködés következtében, ezért vált szükségessé egy C++ implementáció.

\begin{figure}[H]
\centering
\includegraphics[height=60mm, keepaspectratio]{figures/frame3.png}
\includegraphics[height=60mm, keepaspectratio]{figures/frame6.png}
\caption{A C*CS algoritmus megoldása különféle környezetekben} 
\label{fig:ccssolutions}
\end{figure}

%TODO ide kéne pár mérés, hogy ne csak a levegõbe beszéljek
\subsection{Mérések}
Pontos méréseket nem végeztünk, de nagyságrendileg százszoros gyorsulást sikerült elérnünk, és a legbonyolultabb környezetben is egy másodpercen belül sikerült megoldást találnia az algoritmusnak\footnote{Intel Core 2 Duo E8400 @ 3.0GHz, 4GB RAM}. Ez egy igen nagy elõrelépés, így valószínû, hogy egy kisebb teljesítményû beágyazott számítógépen is elfogadható idõn belül végez.

\subsection{Fejlesztési lehetõségek}
A fejlesztés során odafigyeltem, hogy hol lehetne gyorsítani, módosítani a mûködésen. Ahol ez egyszerûen megvalósítható volt, ott ezeket megtettem, de maradtak további fejlesztési lehetõségek is a programban, például számos helyen lehetne a futást párhuzamosítani.

Az esetek nagy többségében a celladekompozíciós eljárással tervezett globális pálya jó eredménnyel szolgál, de néhány speciális esetben -- ilyen például két szûk merõleges folyosó találkozása, nem található megoldás. Részben hasonló probléma mikor a célkonfiguráció és az utolsó szakasz iránya jelentõsen eltér -- ilyen probléma merül fel a párhuzamos parkolás esetén is. Ezek elkerülésére egy másik globális tervezõt kell használnunk.

%----------------------------------------------------------------------------
\section{Új globális tervezõ}
%----------------------------------------------------------------------------
A fejlesztés során a fentebb felsorolt problémák miatt a globális tervezõt lecseréltem az RTR nevû algoritmusra. Ez is Kiss Domokos munkája \cite{DomiRTR}, az implementációját Nagy Ákos végezte el \cite{Akos}. Ez egy, a szakirodalomban széles körben használt RRT (Rapidly Exploring Random Trees) módszeren alapuló pályatervezési eljárás.

%TODO könnszen észrevehetõ, hogy így még maradnak olyan élek a gráfban, melyek nem minden esetben végrehajthatóak. (ez jelenti a problémát)

\subsection{RRT}
A globális tervezõk sok esetben topologikus gráfokat (speciális esetben fákat) használnak a konfigurációs tér struktúrájának leírásához \cite{kavraki96prm}. A szakirodalomban egyik leggyakrabban használt ilyen algoritmus a \emph{Rapidly Exploring Random Trees} \cite{LaValle}. Ennek a lényege, hogy a kezdeti konfigurációból egy fát építünk a szabadon bejárható konfigurációs térben. A fa csomópontjaiban konfigurációk találhatóak, és a fa terjesztését úgy irányítjuk, hogy a kívánt célkonfiguráció felé tartson. Ha a fa ténylegesen eléri a célkonfigurációt, akkor az utat a kezdeti konfigurációból a célkonfigurációba már könnyedén megkaphatjuk.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/RRT.png}
\caption{Az RRT algoritmus három különbözõ iterációnál \cite{LaValle}.} 
\label{fig:RRT}
\end{figure}

\subsection{RTR}
Az \emph{Rotate-Translate-Rotate} algoritmus a fentebb látott RRT algoritmus egy módosított változata. Elsõdlegesen differenciális robotok számára tervez egyenes szakaszokból és egy helyben fordulásokból álló pályát, de jó alapot szolgáltat a C*CS algoritmushoz is. Nevét a benne használt mozgási primitívekrõl kapta, azaz a $R$, mint fordulás, a $T$ pedig az egyenesen haladást jelöli. Az RRT algoritmustól eltérõen itt az algoritmus két fát épít, egyet a kezdõ, egyet pedig a célkonfigurációból. Másik fontos különbség, hogy ütközés esetén a pályát minden irányba továbbterjeszti, így növelve a megoldás megtalálásának lehetõségét.

\begin{figure}[b]
\centering
\includegraphics[width=110mm, keepaspectratio]{figures/rtr_path2.pdf}
\caption{Az RTR algoritmus; piros a kezdõ, kék a célkonfigurációból indított fa. \cite{Akos}}
\label{fig:rtr_path2}
\end{figure}

Ez az algoritmus azért elõnyös, mert a celladekompozíciós eljárás hibáját kiküszöböli. Tehát két szûk folyosó találkozásánál csak akkor ad megoldást, ha van hely az elfordulásra. Mivel a keresés során két fát épít, így a párhuzamos parkolás esetén is segíti a megoldás megtalálását.