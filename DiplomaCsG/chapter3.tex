%----------------------------------------------------------------------------
\chapter{Pályakövetõ szabályozás}
%----------------------------------------------------------------------------
Ebben a fejezetben az elkészült, idõben egyenletesen mintavételezett pálya követésének problémáját mutatom be, majd az ehhez készült szabályozási algoritmusokat mutatom be.

\begin{figure}[H]
\centering
\includegraphics[width=145mm, keepaspectratio]{figures/palyakovetes.pdf}
\caption{A pályakövetés áttekintõ blokkdiagramja.} 
\label{fig:PathFollow}
\end{figure}

%----------------------------------------------------------------------------
\section{Pályakövetés}
%----------------------------------------------------------------------------
Autószerû robot esetén a követendõ pályát szakaszokra bontjuk fel. Egy szegmensen belül a robot megállás nélkül halad elõre vagy hátra a pálya mentén. Ebbõl következik, hogy egy szegmens a haladási irányból, és a pálya idõben egyenletesen mintavételezett pontjaiból áll. Két szakasz közt a robotnak nem szükséges semmilyen speciális feladatot végrehajtani, közvetlenül folytatja a következõ szegmens végrehajtásával\footnote{Ellentétben a differenciális robottal, amely képes egy helyben való elfordulásra, így akár törtszakaszok követésére is.}. Ilyenkor van lehetõség az irány módosítására. Ebbõl következik, hogy a teljes útvonal szegmensekre bontását irányváltoztatások jelzik, az azonos irányú pályaelemeket, mint például amik a C*CS esetén is keletkezhetnek, egy szakaszba egyesíti az algoritmus.

A pályakövetõ szabályozás alapvetõen két szintre oszlik. A felsõbb szinten a pályába kódolt sebesség és pozíció követése a cél, a robot aktuális pozíciója alapján, az alsóbb szinten az így számolt sebesség és kormányszög alapjel szabályozása történik. Ez a szabályozás az algoritmusok szintjén is elkülönül, míg az alsóbb szintû szabályozások magán a roboton, a vezérlésén (esetleg szimulátorán) végrehajthatók, addig a felsõbb szintû szabályozás külön helyen hajtódik végre.

A pályakövetés alapja a szétcsatolt sebesség és orientáció szabályozás. A szétcsatolás következménye, hogy egyszerûbb, lineáris szabályozókat használhatunk a követés során. Hátránya, hogy ez a modell nem minden esetben követi megfelelõen a valóságot.

\subsection{Sebesség szabályozás}
Alacsony szinten a robotsebességénél történik meg a sebességszabályozás. Az általam használt valós robot négy kerék meghajtású, egyetlen DC motor gondoskodik a robot mozgatásáról. A robot középsõ erõátviteli tengelyére csatlakozik egy inkrementális adó, mely biztosítja a sebességszabályozás számára a visszacsatolást. Ahogyan a feszültségvezérelt egyenáramú motorok esetén gyakran lenni szokott, én is egy módosított PI szabályozót használtam sebességszabályozásra.

A PI szabályozók esetében gyakran elõforduló probléma az elintegrálódás \cite{Bezi}. Az elintegrálódás a rendszerben lévõ beavatkozószerv telítése miatt lép fel, kiküszöbölése történhet többféleképpen, szabályozó típusától függõen. Esetünkben egy FOXBORO struktúra segítségével elõzzük meg az elintegrálódást.

Az általam implementált szabályozó figyelembe veszi a motor és mechanika nemlinearitását is. Ehhez fel kellett vegyem a rendszer karakterisztikáját, tehát, hogy egy adott kimeneti feszültség mekkora végsebességet jelent. Ennek a karakterisztikának az inverzét építettük be a rendszer modelljébe, így elméletileg a nemlinearitást kiejtettük.

\subsection{Referenciapont-választás}
A sebességszabályozók számára a sebesség alapjelet a pálya biztosítja, hiszen az idõparaméterezés során olyan pálya készült, amely idõben egyenletesen mintavételezett, és így a pályapontok közötti távolságból a robot sebessége kiszámolható. 

Már csak azt kell eldöntenünk, hogy a pálya melyik pontjához tartozó sebesség alapjelet alkalmazzuk az adott mintavételnél. Ezt hívjuk \emph{referenciapont-választásnak}. Az eljárás elsõ közelítésben igen egyszerû, a pálya pontjai közül a robot pozíciójához legközelebbi pályapontot választjuk referenciapontnak, és így már egyértelmûen adódik a sebesség alapjelünk is.

A fejlesztés egy korai stádiumában felmerült, hogy ezt a referenciapontot ne így határozzam meg, hanem folyamatosan léptessem a pálya mentén. Ezzel kvázi elõírtuk, hogy  a robot adott idõpontban a pálya mely pontjában tartózkodjon. Mivel nem biztos, hogy a robot ténylegesen a kívánt pozícióban található, egy külön szabályozó segítéségével korrigáltam a pályába kódolt sebesség alapjelet, hogy a robot elérje a referenciapontot. 

Amennyiben nem ideális modellt használtunk, a megoldás nem mûködött, a rendszer instabillá vált. Késõbb beláttam, hogy a megoldás problémája az volt, hogy egyrészt elõírtuk a robot számára, hogy mekkora sebességgel haladjon a pálya mentén és a referenciaponton keresztül pedig, hogy hol tartózkodjon az adott idõpontban. Ez már azért sem lehetséges, mivel, ha a robot a referenciaponthoz képest lemaradásban van (általában ez történik), akkor a sebességalapjel korrekció növelné a sebességet, pedig azt már alapból úgy írtuk elõ, hogy a lehetõ leggyorsabban haladjon a robot a pálya mentén. Tehát az alapjel módosító szabályozóval arra kényszerítenénk a rendszert, hogy szegje meg a saját korlátozásait.

\begin{figure}[H]
\centering
\includegraphics[height=75mm, keepaspectratio]{figures/ferdevonal.png}
\caption{Ferde vonal és robot modellje \cite{RobonAUTszem}} 
\label{fig:ferdevonal}
\end{figure}

A végleges megoldásnál ezzel szemben a referenciapontot alakítjuk a robothoz, nem pedig fordítva. Ez azt jelenti, hogy nem írjuk elõ, hogy a robot a pályát mennyi idõ alatt járja be, csak azt, hogy a pálya adott pontjában mekkora sebességgel avatkozzunk be.

A pályakövetõ algoritmusnál lényeges szempont a futási idõ, mivel valós roboton is mûködnie kell. Ezért a referenciapont meghatározásánál nem megyünk végig a pálya összes pontján. A legközelebbi pont keresését az elõzõ iterációban használt referenciapontnál kezdjük, és csak egy bizonyos számú pontot vizsgálunk meg. Ha a robot korlátai megfelelõen lettek beállítva, akkor az egymás utáni referenciapontok között körülbelül egy pályapont különbségnek kell lennie. Ezért teljesen felesleges a pálya összes pontját megvizsgálnunk.

%----------------------------------------------------------------------------
\section{Virtuális vonalkövetõ szabályozás}
%----------------------------------------------------------------------------
Az orientációszabályozás feladata kormányszög alapjel biztosítása a pályakövetés során. Erre a célra egy virtuális vonalkövetést valósítottam meg. A vonalkövetõ autók rendszermodelljénél és szabályozásánál azzal a feltételezéssel élünk, hogy az autó elsõ keréktengelye alatt egy keresztirányú, egydimenziós vonalszenzor helyezkedik el. A jelenlegi esetben a pályakövetõ szabályozás elvét egy ehhez hasonló ``virtuális szenzor'' segítségével fogalmaztam meg. Ez a módszer nagyon hasonló a RobonAUT \cite{RobonAUTszem} versenyen is látott vonalkövetõ autók szabályozására, azzal az elõnnyel, hogy itt sokkal pontosabban ismert a ``vonal'' helye és orientációja.

Mivel egy ilyen vonalkövetõ autó esetén a vonalszenzor mozgására van szükségünk, így módosítani kell a robotunk modelljét (\eqref{carLikeRobot}), amit a következõképpen tehetünk meg:

\begin{align}\label{eq:carLikeRobotMod}
\dot{x} &= v_r \frac{\cos (\theta + \phi)}{\cos \phi} \notag \\
\dot{y} &= v_r \frac{\sin(\theta + \phi)}{\cos \phi} \notag \\
\dot{\theta} &= v_r \frac{\tan \phi}{L},
\end{align}

ahol a jelölések megegyeznek \aref{eq:carLikeRobot} esetén használtakkal, de a továbbiakban a sebességet egyszerûen csak $v$-vel jelöljük. Ezen egyenletek és  \aref{fig:ferdevonal} ábra modellezésével a következõ egyenleteket kapjuk: \cite{RobonAUTszem}

\begin{align}\label{eq:deltaAndp}
\dot{\delta} &= -v \frac{\tan \phi}{L} \notag \\
\dot{p} &= v \cdot \tan \delta - v \cdot \tan \phi - v \cdot \frac{p}{L} \tan \delta \tan \phi
\end{align}

Látható, hogy ez egy nem lineáris rendszer, de a szabályzótervezéshez ezt linearizálnunk kell. Mivel az a célunk, hogy a robot a vonalon, és azzal párhuzamosan helyezkedjen el, így a munkapont, amely körül a linearizálást elvégezzük a $p = 0$, $\phi = 0$ és a $\delta = 0$. Így a következõ egyenletekkel számolhatunk:

\begin{align}\label{eq:linearizedModel}
\dot{\delta} &= - \frac{v}{L} \phi \notag \\
\dot{p} &= v(\delta - \phi - 0)
\end{align}

A linearizálás egyszerû, mert a tangens 0 környezetében jól közelíthetõ az argumentumával. Látható, hogy a $\dot{p}$ esetén az utolsó tagot elhanyagoljuk, mivel a két kis szög szorzata annyira kis számot eredményez, hogy ez gond nélkül megtehetõ. Ha ezt kicsit más formában írjuk fel, rögtön megkapjuk a linearizált rendszer állapotteres leírását:

\begin{align}\label{eq:stateSpace}
x &= [\delta \quad p]^{T} \\ \notag
\dot{x} &= \begin{bmatrix}
0 & 0 \\
v & 0
\end{bmatrix}x + \begin{bmatrix}
-v/L \\
-v
\end{bmatrix} \phi \\ \notag
p &= [0 \quad 1]x + 0 \cdot \phi
\end{align}

Ellentétben egy valós vonalkövetõ autóval, viszonylag pontosan meg tudjuk határozni a rendszer állapotváltozóit. Így célszerû közvetlenül ezek visszacsatolása, mivel  így szabadon megválaszthatóak a visszacsatolt rendszer pólusai. Ezt érdemes úgy megtenni, hogy minimálisra csökkentsük a túllendülést. Ha a rendszer válaszát kéttárolós lengõtaggal közelítjük, akkor annak átviteli függvénye a következõ:

\begin{align}\label{eq:kettarolosLengo}
W(s) = \frac{\omega_{0}^{2}}{\omega_{0}^{2} + 2\xi\omega_{0}s+s^{2}}
\end{align}

ahonnan a pólusok:

\begin{align}\label{eq:polusok}
s_{1,2} = -\omega_{0}\xi \pm j\omega_{0}\sqrt{1-\xi^{2}}
\end{align}

ahol $\omega_{0}$ a rendszer csillapítatlan sajátfrekvenciája és $\xi$ a csillapítási tényezõ. Ha túllendülés mentes rendszert szeretnénk, de a lehetõ leggyorsabb beállási idõvel, akkor $\xi = 1$-et kell választanunk. Az $\omega_{0}$ megválasztására nincsen hasonló korlátozásunk, ezt az aktuális pályához tudjuk igazítani.

Az algoritmust úgy készítettem el, hogy az inicializálási fázisban a kívánt pólusoknak megfelelõen, az Ackermann-képlet \cite{Lantos} segítségével kiszámítja az erõsítési tényezõket, és késõbb ezt használja fel a szabályozási fázisban. Az eredmények azt mutatták, hogy az így készült szabályozóval a szimulációban a robot trajektóriája a kanyarokat levágta. Ez az eredmény egyáltalán nem meglepõ, mivel a szabályozást úgy írtuk fel, hogy az autó eleje kövesse a pályát, de a pályatervezés során a robot referenciapontjának pályáját terveztük meg. Szerencsére ezt egyszerûen orvosolhatjuk, ha a mintavételezett pálya minden pontját eltoljuk az autó hosszával.

%----------------------------------------------------------------------------
%\section{Vonalkövetés valós roboton}
%----------------------------------------------------------------------------
%TODO ide lehetne írni bátran :D