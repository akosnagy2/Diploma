%TODO tolatás

%----------------------------------------------------------------------------
\chapter{Az RTR algoritmus}
%----------------------------------------------------------------------------
Az RTR (Rotate-Translate-Rotate) algoritmust Kiss Domokos dolgozta ki \cite{DomiRTR}. A feladatom az algoritmus implementálása volt C++ nyelven, majd az algoritmus tesztelése szimulációs környezetben és valós roboton.

\par
Az RTR eljárás a szakirodalomból népszerû RRT algoritmuson alapszik, ezért ennek a bemutatásával kezdjük a fejezetet.

%----------------------------------------------------------------------------
\section{RRT algoritmus}
%----------------------------------------------------------------------------
Az RRT (Rapidly Exploring Random Trees) algoritmus lényege, hogy a kezdeti konfigurációból egy fát építünk a szabadon bejárható konfigurációs térben \cite{LaValle}. A fa csomópontjaiban konfigurációk találhatóak, és a fa terjesztését úgy irányítjuk, hogy a kívánt célkonfiguráció felé tartson. Ha a fa ténylegesen eléri a célkonfigurációt, akkor az utat a kezdeti konfigurációból a célkonfigurációba már könnyedén megkaphatjuk.
\par
Létezik olyan változata az RRT algoritmusnak, ahol nemcsak a kezdeti konfigurációból építünk fát, hanem a célkonfigurációból, vagy akár több köztes pontból is.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/RRT.png}
\caption{Az RRT algoritmus három különbözõ iterációnál \cite{LaValle}.} 
\label{fig:RRT}
\end{figure}

\par
A fa építés úgy kezdõdik, hogy véletlen konfigurációkat veszünk a környezetbõl ($q_{rand}$). Ezt hívják \emph{mintavételezési szakasznak}. Ezután meghatározzuk, hogy a fában melyik konfiguráció van a legközelebb a mintavételezett konfigurációhoz ($q_{near}$). Ez a \emph{csomópont kiválasztó szakasz}. Egy lehetséges megoldás, hogy a fa csomópontjaiból választunk konfigurációkat, vagy elõfordulhat, hogy a fa csúcspontjai közötti élek egy köztes konfigurációját választjuk.

\par
A következõ lépésben megpróbáljuk a $q_{rand}$ és a $q_{near}$ konfigurációkat interpolációval összekötni (\emph{összekötõ szakasz}). Itt több variációja is létezik az RRT algoritmusnak. Elõfordul, hogy $q_{near}$ konfigurációból csak egy bizonyos fix $\Delta q$ értékkel közelítünk $q_{rand}$ felé. A másik esetben addig terjesztjük a fát, amíg el nem érjük $q_{rand}$ konfigurációt, vagy amíg nem ütközik a robot. Ebben az esetben a kapott konfiguráció a legmesszebb található ütközésmentes konfiguráció lesz $q_{rand}$ irányában. Az újonnan kapott konfigurációt végül hozzáadjuk a fához.

\par
Anholonom rendszerek esetén is használható az RRT eljárás. Ekkor az összekötésnél egyszerû interpolációt nem lehet alkalmazni, mert az azt feltételezné, hogy a robot minden irányba szabadon képes mozogni. Ehelyett az összekötést egy lokális tervezõ segítségével kell  megoldani, vagy egyszerûbb esetben itt is használható az a módszer, hogy csak egy adott $\Delta q$ értékkel közelítünk $q_{rand}$ irányába. Ehhez megfelelõ beavatkozó jelet ($\Delta u$) kell választanunk, amit $\Delta t$ ideig alkalmazva elérhetõ $\Delta q$ állapotváltozás. A $\Delta u$ beavatkozójel például differenciális robot esetén, a két kerék sebessége.

\par
Az elõbb ismertetett fázisok alkotják a fa terjesztésének egy lépését. Több fa esetén természetesen mindegyiknél végre kell hajtani a fázisokat. A terjesztést addig kell folytatni, amíg el nem érjük a kívánt konfigurációt, vagy több fa esetében, amíg a fák nem kapcsolhatók össze.

%----------------------------------------------------------------------------
\section{RTR algoritmus}
%----------------------------------------------------------------------------
Ha differenciális robotnál használunk valamilyen $\Delta u$ beavatkozójelet az összekötõ fázisban, akkor a fa csúcspontjai között görbék lesznek. Ez nehézséget okozhat, ha olyan \emph{csomópont-választó eljárást} alkalmazunk, ami köztes konfigurációt ad vissza. Természetesen alkalmazhatjuk azt az eljárást, hogy csak az élek végpontjait választjuk ki, köztük nem interpolálunk. Ehhez viszont kis távolságú élek szükségesek, ami növeli a fa csomópontjainak számát és ezzel összefüggésben a csomópont kiválasztások számát is.

\par
Lehetõségünk van differenciális robotnál is lokális tervezõt alkalmazni két konfiguráció közti állapotváltozásra. A legegyszerûbb lokális tervezõ három lépésbõl áll:

\begin{itemize}
\item Egy helyben fordulás a kívánt konfiguráció irányába (R).
\item Mozgás egyenes pályán a célpozícióba (T).
\item Egy helyben fordulás a célkonfiguráció irányába (R).
\end{itemize}

\par
Ennek a tervezõnek az az elõnye, hogy a fa élei egyenes pályák lesznek, így egyszerûen tudjuk meghatározni a köztes konfigurációkat.

\par
A jelenleg ismertetett módon alkalmazva az RRT algoritmust, szûk folyosók esetében rendkívül nehezen találna megoldást az eljárás, abban az esetben is, ha mind a kezdeti-, mind a célkonfigurációból növesztünk egy-egy fát. A problémát az okozza, hogy az \emph{összekötés fázisa} gyakran nem ad eredményt, ezért a fák nem nõnek megfelelõen. Ennek az az oka, hogy a lokális tervezõ használatakor, fal vagy egyéb akadályok közelében az elsõ egy helyben fordulásnál már ütközne a robot. Mivel az összeköttetés fázisa addig tart, amíg nem érjük el $q_{rand}$-ot, vagy amíg nem ütközik a robot, így a fa további terjesztése nélkül választunk új $q_{rand}$ értéket. A lokális tervezõ második lépése eredményezné a fa tényleges terjesztését.

\par
Az RTR algoritmus, felhasználva az RRT eljárás elõnyös tulajdonságait, igyekszik az elõbbi problémára egy lehetséges megoldást bemutatni. Mind a kezdeti, mind a célkonfigurációból növeszt egy-egy fát, az összekötõ fázisban a fent ismertetett lokális tervezõt alkalmazza. Az RRT eljárás mindhárom fázisa módosításra kerül az RTR tervezõ esetében.

Az RTR algoritmusnál alkalmazott fa struktúrában, az RRT-hez hasonlóan a csomópontokban konfigurációk találhatóak, az élek pedig transzlációs mozgást (TCI - Translation Configuration Interval) vagy egy helyben fordulást írnak le (Rotational Configuration Interval). Egy adott TCI vagy RCI leírható két konfigurációval és TCI esetén a köztük lévõ távolsággal, míg RCI esetén a köztük lévõ szögtávolsággal. Természetesen RCI esetén a két konfiguráció pozíciója megegyezik, TCI esetén pedig a két konfiguráció iránya egyezik meg. Fontos észrevennünk, hogy mindkét éltípust egzakt módon írjuk le, mintavételezés nélkül.

%----------------------------------------------------------------------------
\subsection{Mintavételezés}
%----------------------------------------------------------------------------

\par
A mintavételezés fázisában különbséget jelent az eredeti RRT algoritmushoz képest, hogy a mi esetünkben a $q_{rand}$-nak megfelelõ véletlen minta nem egy konfiguráció lesz, hanem egy pozíció a térben ($p_G$). Ezt a pozíciót tekinthetjük egy folytonos, egy dimenziós konfigurációs listának, amelynek bármelyik eleme megfelelõ célkonfiguráció lehet.

\par
A mintavételezést kiegészíthetjük a pálya háromszög cellafelbontásából kapott mintákkal (\ref{sect:fade2d}. fejezet). Ezek a minták az akadályoktól természetszerûleg viszonylag távol találhatóak, és szûk folyosók esetén is segítenek terjeszteni a fákat. 
%TODO ezt rendesen vagy itt vagy ott

%----------------------------------------------------------------------------
\subsection{Csomópont kiválasztás} \label{sect:ALC}
%----------------------------------------------------------------------------
Mivel a mintavételezésnél pozíciót használunk és nem konfigurációt, ezért a \emph{csomópont kiválasztás} egyszerûbb lesz. Az eljárás lényege, hogy az adott $p_G$ esetén végigmegyünk a fa élein és meghatározzuk a legkisebb távolságot a $p_G$ pont és az adott él között. TCI él esetében ez távolságot jelent, RCI esetében pedig szögtávolságot. Így minden egyes élnél kapunk egy konfigurációt, amely esetében a távolság a $p_G$-tõl minimális. A kapott konfigurációk közül azt választjuk, amelyiknél legkisebb a távolság $p_G$-hez képest, és ha így több megoldást is kapunk, akkor pedig azt a konfigurációt választjuk, amelynél a szögtávolság a legkisebb. Így egyértelmûen meghatároztuk $q_{near}$-t.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/tci_gp.png}
\caption{Csomópont kiválasztás TCI esetén. A bal oldali ábra esetén köztes konfigurációt kapunk, míg a jobb oldali ábrán nem.} 
\label{fig:tci_gp}
\end{figure}

\par
Egy adott TCI és $p_G$ esetén a legkisebb távolsághoz tartozó konfigurációt a következõképpen határozzuk meg (\ref{fig:tci_gp}. ábra). Kiszámoljuk a $p_G$ pont merõleges vetületét a TCI-t alkotó egyenesre, ezután meghatározzuk, hogy a vetület a TCI-n, mint szakaszon belül található-e. Ha a szakaszon belül található a vetület, akkor egy köztes konfiguráció van legközelebb $p_G$-hez. A köztes konfiguráció pozíciója a vetület, orientációja pedig a TCI orientációja. Ha a szakaszon kívül található a vetület, akkor a TCI közelebbi konfigurációja lesz a legkisebb távolságú konfiguráció.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/rci_gp.png}
\caption{\emph{Csomópont kiválasztás} RCI esetén. A bal oldali ábra esetén köztes konfigurációt kapunk, míg a jobb oldali ábrán nem.} 
\label{fig:rci_gp}
\end{figure}

\par
RCI esetén a legkisebb (szög)távolságú konfiguráció kiválasztása \aref{fig:rci_gp}. ábrán látható. Elõször kiszámoljuk a $p_G$ pont és az RCI pozíciójának irányát. Ha a kapott irány az RCI (szög)tartományába beleesik, akkor köztes konfigurációról van szó (bal oldali ábra) és ekkor a legközelebbi konfiguráció az RCI pozíciója és az elõbb kiszámolt orientáció lesz. Abban az esetben, amikor a kapott irány nem esik bele az RCI tartományába, akkor az RCI irányban közelebbi szélsõ konfigurációját választjuk (jobb oldali ábra).

%----------------------------------------------------------------------------
\subsection{Kiterjesztés}
%----------------------------------------------------------------------------

Az RTR algoritmus ezen fázisa különbözik leginkább az eredeti RRT algoritmustól. Különbség, hogy a transzlációs szakasz esetében nemcsak elõre, hanem hátra is kiterjesztjük a fát. Ezenkívül a kiterjesztés nem $p_G$-ig történik, hanem mindenképpen addig, amíg nem ütközik a robot. Ez mindkét irányra érvényes. Fontos megjegyezni, hogy a kiterjesztés során az RTR lokális tervezõ elsõ két elemét használjuk fel (RT), tehát a második forgatást nem hajtjuk végre. 

\par
Lényeges különbség az is, ahogyan a két algoritmus az ütközést kezeli. Az RTR tervezõ esetén ütközés esetén különbséget kell tenni, hogy transzlációs vagy forgatási fázisban történt-e ütközés. Amennyiben transzlációs fázisban történt ütközés, az adott iterációnak vége lesz, hiszen a fát már kiterjesztettük. Ugyanez történne az RRT eljárásnál is.

\begin{figure}[H]
\centering
\includegraphics[width=80mm, keepaspectratio]{figures/rtr_rci.png}
\caption{\emph{A kiterjesztés folyamata.}\cite{DomiRTR}} 
\label{fig:rtr_rci}
\end{figure}

\par
Amennyiben forgatás közben történik ütközés a helyzet bonyolultabb, mivel ilyenkor nem sikerült kiterjeszteni még a fát. Ekkor az ütközési orientációnál elõre és hátra terjesztjük ki a fát. Ezután a célorientációt megpróbáljuk másik körüljárás szerint elérni. Függetlenül attól, hogy sikerült-e a második forgatással elérni a célkonfigurációt vagy ütközött a robot, ebben az állapotban megint kiterjesztjük a fát elõre és hátra is. Amennyiben ütközés történt megint az ütközési orientációnál alkalmazzuk a kiterjesztést, különben pedig a célkonfiguráció irányában terjesztjük ki a fát. A folyamat \aref{fig:rtr_rci}. ábrán látható.

\par
A fa terjesztésnél alapvetõen két célunk van, egyrészt, hogy a célkonfiguráció felé haladjunk, másrészt pedig, hogy minél nagyobb szabad területet bejárjunk.

%----------------------------------------------------------------------------
\subsubsection{Ütközésdetektálás transzlációs kiterjesztés esetén} \label{sect:tci}
%----------------------------------------------------------------------------
A robot transzlációs kiterjesztése elõre- és hátrafelé is a következõk szerint történik. Minden egyes akadály esetén, beleértve a pályát határoló téglalapot is, végigmegyünk a robot alakját leíró polygon összes csúcspontján. Adott csúcspont esetén megvizsgáljuk, hogy a kiterjesztés irányában metszi-e a vizsgált akadály oldalát, és ha igen, akkor eltároljuk az ütközésig megtehetõ távolságot. Ezután megvizsgáljuk, hogy az adott akadály csúcspontjai a mozgás során metszik-e a robot éleit, és szintén eltároljuk az ütközésig lévõ távolságot. A minimális távolság a letárolt távolságok minimuma lesz. 

\par
A fent leírtaknál minden esetben egy egyenes és egy szakasz metszetét kell kiszámítanunk, majd megvizsgálni, hogy a metszéspont a mozgás irányában található-e. A szakasz a robot vagy az akadály egyik éle, az egyenes pedig az akadály vagy a robot egyik csúcspontja a transzláció irányában. \Aref{fig:tci_coll}. ábra mutatja a kiterjesztést egy adott akadály és a robot között.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/tci_coll2.png}
\caption{Transzlációs kiterjesztés esetében az ütközésvizsgálat.} 
\label{fig:tci_coll}
\end{figure}

%----------------------------------------------------------------------------
\subsubsection{Ütközésdetektálás forgatás esetén} \label{sect:rci}
%----------------------------------------------------------------------------
A forgatás közbeni ütközésvizsgálat hasonlóképpen történik, mint transzlációnál. Itt is végigmegyünk az összes akadályon és mindegyiknél megvizsgáljuk a robot összes élét és csúcspontját. Itt is két irányban ellenõrzünk, a robot éleit és az akadály csúcspontjait, valamint az akadály éleit és a robot csúcspontjait vizsgáljuk. A kapott szögelfordulások közül a minimális elfordulást használjuk fel késõbb.

\par
Különbséget jelent, hogy itt egy körív és egy szakasz közti metszéspontot kell számolnunk. A szakasz a robot vagy akadály egyik éle. A körívet pedig úgy kapjuk meg, hogy a robot vagy akadály csúcspontját a robot pozíciója körül elforgatjuk az adott forgási szöggel.

%----------------------------------------------------------------------------
\subsection{Útvonal meghatározása, optimalizálása} \label{sect:merge_opt}
%----------------------------------------------------------------------------
Az RTR algoritmus sikeres futásához szükséges, hogy a kezdõ és a célkonfigurációból terjesztett fák kapcsolódjanak egymáshoz. Ezért minden iteráció végén ellenõrizzük, hogy a legutóbb felvett TCI-k és a másik fa között létesíthetõ-e ütközésmentes kapcsolat egy RCI segítségével. Ha ez lehetséges, akkor a metszéspontból vissza kell mennünk a fák kezdõpontjáig, és így megkapjuk a keresett útvonalat a kezdõ konfigurációból a célkonfigurációig. A kapott útvonalat egy TCI-ket és RCI-ket tartalmazó listaként képzelhetjük el.

\par
Egy TCI és egy fa összekapcsolásának vizsgálata során a fát Breadth-First szélességi keresés segítségével járjuk be \cite{BFS}. Az algoritmus egy FIFO szerkezetû tárolót használ, amely kezdetben a fa forrásainak gyerekeit tartalmazza. Ezután kivesszük a tárolóból az elsõ elemet és ha az TCI, akkor megvizsgáljuk, hogy összevonható-e a vizsgált TCI-vel. Ha összevonható, akkor befejeztük a vizsgálatot, ha nem akkor pedig a TCI gyerekeit berakjuk a tárolóba. Ha RCI volt a kivett elem, akkor egyszerûen a gyerekeit berakjuk a tárolóba. Az algoritmust addig futtatjuk, amíg a tároló nem ürül ki vagy nem találtunk összevonható TCI-ket. Abban az esetben ha üres lesz a tároló, a vizsgált TCI és a fa nem vonható össze.

\par
Azt, hogy két TCI összevonható-e, egyszerûen eldönthetjük. Fogjuk a két TCI által leírt szakaszokat és megnézzük, hogy van-e metszéspontjuk. Ha nincsen, akkor biztosak lehetünk benne, hogy nem vonhatóak össze. Ha van metszéspontjuk, meg kell vizsgálnunk, hogy a metszéspontból találunk-e egy RCI-t, amely a két szakasz között ütközésmentes mozgást biztosít. Itt ugyanúgy járhatunk el, ahogy a kiterjesztés fázisában tettük \aref{sect:rci}. részben. Ha nem sikerül ütközésmentes forgatást találnunk, ellentétes körüljárás szerint is megpróbálunk RCI-t keresni, ha így sem találunk, akkor a két TCI nem összevonható.

\par
Abban az esetben, ha több útvonalat is találnánk a két fa között, akkor azt az útvonalat választjuk, amelyik a legkevesebb konfigurációból áll. Ha több ilyen út is van, akkor azok közül a legrövidebb távolságú útvonalat választjuk.

\par
Miután megkaptuk az útvonalat, még további optimalizációt végezhetünk el rajta. Az elsõ módszer lényege, hogy az egymás után következõ több TCI-t, egy TCI-vel helyettesítjük. Ezt minden esetben megtehetjük, hiszen ha a TCI-k között nincsen RCI, akkor azoknak az iránya nem változik, egy egyenesen helyezkednek el.

\par
A második lehetõség, hogy az összes TCI-t a kapott útvonalban kiterjesztjük, majd az így létrehozott kiterjesztett útvonal segítségével optimalizálunk. Felmerülhet, hogy miért van értelme kiterjeszteni a TCI-okat, hiszen ezeket úgy hoztuk létre, hogy nem $p_G$ pozícióig történik a terjesztés, hanem amíg a robot nem ütközik. Azonban a \emph{csomópont kiválasztásnál} köztes konfigurációkat is kiválasztunk, és így olyan TCI-k jönnek létre, amelyek nincsenek ütközésig terjesztve. Az optimalizálás lényege, hogy végigmegyünk a kiterjesztett útvonalon, és minden TCI esetében a kiterjesztett pálya végérõl elindulva olyan TCI-kat keresünk, amelyeket össze lehet vonni. Két TCI-ról a fent ismertetett módon döntjük el, hogy összevonhatók-e.  Ezzel a módszerrel a végleges útvonal hossza jelentõsen csökkenthetõ.

%----------------------------------------------------------------------------
\section{Implementálás}
%----------------------------------------------------------------------------
Az algoritmus megvalósítását C++ nyelven végeztem el. Az implementáláshoz rendelkezésre állt az RTR tervezõ MATLAB környezetben megvalósított programkódja.

\par
Az RTR tervezõ egyszerûsített pszeudokódja \aref{alg:rtr}. algoritmusnál látható. Az algoritmus felépítése hasonló az eredeti RRT eljáráshoz \cite{LaValle}. 

\par
Az algoritmus minden iterációban továbbterjeszti a konfigurációs fákat. A terjesztés mindkét fa esetében ugyanúgy történik (\emph{IterateTree} metódus). Látható, hogy az \emph{IterateTree} metódus az RTR eljárás három fõ lépését hajtja végre. A \emph{GetGuidePoint} függvény a szabad konfigurációs térbõl véletlenszerûen kiválaszt egy pozíciót (mintavételezési szakasz), a \emph{GetALC} függvény megkeresi az eddig bejárt fában a mintavételezett ponthoz tartozó legközelebbi konfigurációt (csomópont kiválasztás) és a \emph{TurnAndExtend} függvény felelõs a fa kiterjesztéséért. 

\par
A \emph{MergeTreesGetPath} és a \emph{OptimizePath} függvények \aref{sect:merge_opt}. részben leírtakat valósítják meg. A \emph{MergeTreesGetPath} a két fa között próbál összekötést találni egy, míg a \emph{OptimizePath} a már megkapott útvonalt optimalizálja, hogy minél rövidebb legyen.

\begin{algorithm}[H]
\floatname{algorithm}{Algoritmus}
\caption{RTR tervezõ}\label{alg:rtr}
\begin{algorithmic}
\Procedure{RTRPlanner}{}
\State \Call{InitTree}{$start$}
\State \Call{InitTree}{$goal$}
\While{$iteration \leq maxIter$}
\State \Call{IterateTree}{$start$}
\State \Call{IterateTree}{$goal$}
\If {\Call{MergeTreesGetPath()}{}}
\State \Call{OptimizePath()}{}
\State \textbf{break}
\EndIf
\EndWhile\label{euclidendwhile}
\EndProcedure
\\
\Procedure{IterateTree}{$tree$}
\State $p_G \gets$ GetGuidePoint($tree$)
\State $alc \gets$ GetALC($p_G$, $tree$)
\If {\Call{TurnAndExtend($p_G$, $tree$, $alc$, $positive$)}{}}
\State \Call{TurnAndExtend($p_G$, $tree$, $alc$, $negative$)}{}
\EndIf
\EndProcedure
%\\
%\Procedure{MergeTree}{$tree$}
%\State $p_G \gets$ GetGuidePoint($tree$)
%\State $alc \gets$ GetALC($p_G$, $tree$)
%\If {\Call{TurnAndExtend($p_G$, $tree$, $alc$, $positive$)}{}}
%\State \Call{TurnAndExtend($p_G$, $tree$, $alc$, $negative$)}{}
%\EndIf
%\EndProcedure
\end{algorithmic}
\end{algorithm}

A konfigurációs fa elemeinek leírására a \emph{TreeElement} osztály szolgál, amely a következõ tagokkal rendelkezik:

\begin{align}\label{eq:TreeElement}
parentElement& : \text{A szülõ azonosítója} \notag\\
childrenElements& : \text{A fa elemének gyerekeit tartalmazó vektor}\notag\\
CI& : \text{A fa elemét meghatározó TCI vagy RCI leírása}
\end{align}

A \emph{TreeElement} osztályban található \emph{CI} tagváltozót pedig a \emph{ConfigInterval} osztály írja le:

\begin{align}\label{eq:ConfigInterval}
type& : \text{A CI tipusa: RCI vagy TCI} \notag\\
q0& : \text{A CI kiindulási konfigurációja}\notag\\
q1& : \text{A CI cél konfigurációja} \notag  \\
amount& : \text{Elõjeles távolság a két konfiguráció között}
\end{align}

Ezenkívül természetesen külön osztályt alkotnak a konfigurációk, a különbözõ geometriai primitívek (kör, egyenes, háromszög, sokszög, pont). Ezeknek a pontos leírása a dolgozat mellékletében megtalálható a forráskódokban.

Mind a két folyamatosan növesztett fát \emph{TreeElement}-ekbõl álló dinamikus tömbben tárolom, amire a C++ nyelv \emph{Vector} tároló típusát használom. A \emph{Vector} típus egy tömbben, folytonos memória területen tárolja az elemeket. A dinamikus memória foglalást és felszabadítást a tároló automatikusan elvégzi.

Kipróbáltam más tárolókat is, mint például \emph{List} típust. A \emph{List} egy kétszeresen láncolt lista. Adott elem törlése és beszúrása \emph{List} esetén gyorsabb, mint \emph{Vector} esetében. A mi esetünkben azonban nem szükséges a tömbbe közbülsõ elemeket beszúrni, az új elemek a tömb végére kerülnek.

A \emph{Deque} típus hasonló a \emph{Vector}-hoz, csak ennél a tárolónál a tömb elejére is hatékonyan lehet elemeket beszúrni és törölni, nemcsak a tömb végére. Viszont a tárolásra nem folytonos memória területet használ.

Az elõbb említett három tároló típust egy mérés segítségével is összehasonlítottam. A mérés során fixen 10000 iterációig futott az algoritmus és a \emph{IterateTree} függvény futási idejét mértem mindkét fa esetében. Amennyiben futás közben talált volna megfelelõ útvonalat az algoritmus, akkor sem fejezte be a futást, 10000 iterációit mindenképpen végrehajtott. A \emph{MergeTreesGetPath} függvényt azért nem mértem a teszt során, mivel a gyakorlatban csak addig fut az algoritmus, amíg nem lesz meg az elsõ megfelelõ út, és ez a tény jelentõsen befolyásolja a \emph{MergeTreesGetPath} függvény futási idejét.

A mérés elvégzéséhez a C++ nyelvben található \emph{high\_resolution\_clock} osztályt használtam, amely a C++11 szabvány része, és kifejezetten idõmérésre lett kialakítva. 

\begin{figure}[H]
\centering
\includegraphics[width=135mm, keepaspectratio]{figures/measureData.pdf}
\caption{A különbözõ C++ tároló típusok összehasonlítása. Az idõmérés felbontása 100 ns.} 
\label{fig:measureDataTypes}
\end{figure}

A mérés ábráján (\ref{fig:measureDataTypes}. ábra) látható, hogy mekkora különbséget okozz a választott tároló típus. A mérés alapján úgy gondolom, jó választás volt a \emph{Vector} használata, mert a többi tároló esetében nagyobb futási idõ adódik, ha a különbség nem is túlságosan nagy. Általánosságban azt tanácsolják, hogy célszerû \emph{Vector} típust használni tároláshoz, az esetek nagy részében így kapjuk a leghatékonyabb programkódot.

Az ábráról az is leolvasható, hogy a iterációk számának növekedésével (fa terjesztésével) egy iteráció futási ideje lineárisan nõ. Ez azért van így, mert a \emph{GetALC} függvénynek végig kell mennie a teljes fán, hogy megállapítsa, hogy melyik konfiguráció van a mintavételezett pozícióhoz legközelebb. Ez az egy függvény okozza azt, hogy lineárisan nõ a futási idõ a fa növekedésével.  Ha azt vizsgáljuk, hogy adott számú iteráció futásához mennyi idõ szükséges, akkor az négyzetesen fog nõni az iteráció szám növelésével.

Az algoritmus futási idejét a Microsoft Visual Studio beépített Profiler eszközével is megvizsgáltam. A Profiler a program futása során mintákat gyûjt (ezt jelöli \aref{table:Prof}. táblázat \emph{Mintavétel} oszlopa), és eltárolja minden mintához, hogy a program melyik része futott. Ennél a tesztnél már a teljes algoritmust használtam, nemcsak az \emph{IterateTree} függvényt, és az algoritmus akkor fejezte be futását, ha talált utat a kezdõ és cél konfiguráció között.

\begin{table}
\centering
\begin{tabular}{l*{6}{c}r} 
Függvény neve              	& Mintavétel 	& Mintavétel [\%] & Futási idõ [s]\\
\hline
RTRPlanner					& 5433 	& 100.00 	& 17.36\\
GetALC 					   	& 2574 	& 47.37 	& 8.22\\
MergeTreesGetPath           & 2205 	& 40.59 	& 7.05\\
TurnAndExtend           	& 652  	& 12.00 	& 2.08\\
OptimizePath     			& 2 	& 0.04 		& 0.01\\
\end{tabular}
\caption{Az algoritmus vizsgálata Profiler segítségével. A méréshez használt pálya \aref{fig:rtr_path3}. ábrán látható.}
\label{table:Prof}
\end{table}
 
A Profiler eredményeit \aref{table:Prof}. táblázat mutatja be. Az eredmények megfelelnek a várakozásainknak, mivel az idõ nagy részében a \emph{GetALC} függvény fut. Ezenkívül a \emph{MergeTreesGetPath} függvényhez tartozik jelentõs processzor idõ. Ez logikus, hiszen ennél a függvénynél is végig kell menni a teljes fákon, hogy eldöntsük a két fa összevonhatóságát.

%----------------------------------------------------------------------------
\subsection{Optimalizálások}
%----------------------------------------------------------------------------

Megvizsgálva az algoritmust, a következõ egyszerûbb optimalizálásokat végezhetjük el a programon. Mivel a \emph{GetALC} függvény (csomópont kiválasztás) a legkritikusabb függvény, ezért próbáljuk meg elsõsorban ezen optimalizálni.

A csomópont kiválasztás lényege, hogy megkeressük a legközelebbi konfigurációt a mintavételezett pozícióhoz ($p_G$). Legközelebbi konfiguráció alatt távolságban legközelebbit értjük, abban az esetben, ha több ilyen konfigurációt találunk, az elfordulásban közelebbi konfigurációt választjuk. Ennek a menetét \aref{sect:ALC}. fejezetben tárgyaltuk részletesen. A csomópont kiválasztást gyorsíthatjuk, ha az adott TCI/RCI és a $p_G$ pont közötti vizsgálatot abbahagyjuk, ha a kapott távolság biztosan nagyobb lesz, mint az addigi minimális távolságú konfiguráció esetén. Ezzel TCI és RCI esetén nem szükséges kiszámolni a $p_G$ és a konfiguráció közti szögtávolságot, ami jelentõs javulást eredményez, mivel a szögtávolság meghatározásához \emph{atan2} mûveletet kell használunk.

Az algoritmusnál gyakran elõfordul, hogy távolságokat kell összehasonlítanunk (\emph{GetALC} esetén is). Ezeknél a részeknél élhetünk azzal a triviális optimalizálással, hogy távolságnégyzetet számolunk, tehát megspórolunk egy négyzetgyökvonást.

Megvizsgálva \aref{sect:rci}. fejezetekben tárgyalt ütközésvizsgálatot, a következõ optimalizálást végezhetjük el. Amennyiben a robot egy akadálytól messze található, akkor értelmetlen az egy helyben fordulásnál ütközésdetektálást végezni. Annak az eldöntése, hogy a robot messze található egy adott akadálytól, a következõképpen történik. Kiszámoljuk az RTR algoritmus elején, hogy mekkora a robot fordulási körének sugara és mekkora az akadályokat leíró sokszögek köré írható körének sugara. E körök segítségével meg tudjuk határozni egy akadályról, hogy messze található-e a robot aktuális pozíciójától. Ez a megoldás a \emph{MergeTreesGetPath} függvény futási idejét is csökkenti.

\begin{table}
\centering
\begin{tabular}{l*{6}{c}r}
Függvény neve              	& Mintavétel 	& Mintavétel [\%] & Futási idõ [s]\\
\hline
RTRPlanner					& 2669 	& 100.00 	& 8.55\\
MergeTreesGetPath           & 1786 	& 66.92 	& 5.72\\
GetALC 					   	& 573 	& 21.47 	& 1.84\\
TurnAndExtend           	& 307  	& 11.50 	& 0.98\\
OptimizePath     			& 3 	& 0.11 		& 0.01\\
\end{tabular}
\caption{Az algoritmus vizsgálata optimalizálás után Profiler segítségével}
\label{table:Prof2}
\end{table}

Az ismertetett egyszerûbb optimalizálásokkal \aref{table:Prof2}. táblázatban látható futási eredményeket kapjuk a Profiler program alapján. A táblázat értékei alapján elmondhatjuk, hogy sikerült az algoritmus futási idejét az adott pálya esetében felére csökkenteni. Ezenkívül szembetûnõ különbség az optimalizálás elõtti eredményhez képest, hogy a \emph{GetALC} függvény futása 60\%-ról 40\%-ra csökkent. Tehát a csomópont kiválasztásnál alkalmazott optimalizálások, egyszerûségük ellenére igen hatásosak voltak.

Az algoritmus futási idejét összehasonlíthatjuk az implementálás alapjául szolgáló MATLAB szkript futási idejével. Egy konkrét pálya esetében a Matlab szkriptben megvalósított algoritmus átlagosan ~24 s alatt futott le, míg a C++ nyelvû megvalósítás esetén ~21 ms alatt. Tehát körülbelül 3 nagyságrenddel lett gyorsabb a C++ változat. 

Természetesen a MATLAB szkriptben megírt változat elsõdleges feladata az algoritmus bemutatása, és nem a minél rövidebb futási idõ elérése volt. Azonban bonyolultabb pályák esetében igazán hasznos a három nagyságrenddel rövidebb futási idõ, például a Profiler által az elõbbiekben tesztelt pálya esetében MATLAB szkript esetén hozzávetõleg két és fél óra lenne a futási idõ.

Véleményem szerint a két megvalósítás közötti különbség legfõképpen abból adódik, hogy MATLAB esetében interpretált módon hajtjuk végre a programkódot, míg a C++ nyelvnél a programkód fordításra kerül, ráadásul a fordító optimalizálás után készíti el a processzor által végrehajtandó gépi kódot.

%----------------------------------------------------------------------------
\section{Eredmények}
%----------------------------------------------------------------------------

Most pedig bemutatjuk az RTR pályatervezõ által generált pályákat. \Aref{fig:rtr_path}. ábrán látható az algoritmus által tervezett pálya, valamint a pálya sarokpontjaiban a robot helyzete. A kezdõ- és végkonfigurációt külön kiemeltük zöld és piros színekkel. 

Szimulációs eredmények alapján belátható, hogy az RTR tervezõ szûk folyosókat tartalmazó pályák esetében jobb eredményt ad, mintha az egyszerû RRT eljárást alkalmaznánk differenciális robotnál \cite{DomiRTR}. 

\begin{figure}[H]
\centering
\includegraphics[width=80mm, keepaspectratio]{figures/rtr_path0.png}
\caption{Az RTR algoritmus által megtervezett útvonal egy akadály esetén.} 
\label{fig:rtr_path}
\end{figure}

Bonyolultabb környezet esetén felerõsödik a véletlen mintavételezés szerepe, az egymás utáni futtatások között nagyobb eltérés mutatkozhat. \Aref{fig:rtr_path2}. ábrán látható útvonalat 35 iteráció után találta meg az RTR tervezõ, de elõfordult, hogy egy hasonló úthoz 130 iterációra volt szüksége ugyanennél a pályánál. Ennél a pályánál a kezdõ és végkonfigurációból terjesztett fákat is ábrázoltuk.

\begin{figure}[H]
\centering
\includegraphics[width=90mm, keepaspectratio]{figures/rtr_path1.png}
\caption{Az RTR algoritmus által megtervezett útvonal bonyolultabb környezet esetén.} 
\label{fig:rtr_path2}
\end{figure}

\Aref{fig:rtr_path3}. ábrán látható pálya esetében vizsgáltuk az RTR algoritmus futási eredményeit \aref{table:Prof}. és a \aref{table:Prof2}. táblázatoknál. Látható, hogy a pálya két részén igen szûk kanyarban kell elfordulnia a robotnak. Ekkor a robot nagyon kis (1 milliméter alatti) mozgásokat hajt végre. Összehasonlításképpen a pálya 6 méter széles és 2.5 méter magas. Ezen pálya megtalálásához 3000-5000 iterációra volt szükség, teljesen véletlen mintavételezés esetén, tehát nem használjuk fel a celladekompozíció által adott pontokat.

\begin{figure}[H]
\centering
\includegraphics[width=140mm, keepaspectratio]{figures/rtr_path2.png}
\caption{Az futás idõk mérésekor használt környezet.} 
\label{fig:rtr_path3}
\end{figure}