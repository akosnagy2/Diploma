%----------------------------------------------------------------------------
\chapter{A C*CS, \boldmath{$c\overline{c}S$} algoritmus}
%----------------------------------------------------------------------------
A C*CS és a $c\overline{c}S$ algoritmus is Kiss Domonkos munkája. Az algoritmusok elsõdlegesen autószerû robotok számára terveznek pályát, de az így tervezett pálya egy differenciális robot számára is végrehajtható. A mi feladatunk az algoritmus implementálása volt C++ nyelven, majd annak tesztelése szimulációs, illetve valós környezetben.
A fejezetet az algoritmus ismertetésével kezdjük, majd kitérünk az implementációs problémákra, és az elért eredményekre is.

%----------------------------------------------------------------------------
\section{Reeds-Shepp lokális pályák}
%----------------------------------------------------------------------------
Anholonóm rendszerek irányítása akadályoktól mentes környezetben is egy igen bonyolult feladat, sok esetben nem adható meg általános algoritmus, csak néhány speciális rendszer esetén. Szerencsére ilyen rendszerek közé tartoznak a differenciális robotok, az autószerû robotok melyek csak elõre mozoghatnak (Dubins autó) és azok melyek elõre és hátra is mozogni képesek.

\par
Az utóbbi típusú robotokat hívjuk Reeds-Shepp autóknak, melyeknél bizonyított, hogy bármely kezdõ- és célkonfiguráció közt, a legrövidebb utat megtalálhatjuk 48 lehetséges megoldás közül, ahol ezek a megoldások maximum öt egyenes vagy kör kombinációjából állnak, és ezek a pályák maximum két csúcspontból állnak, azaz ennyiszer kell irányt változtatni a végrehajtás közben. A megoldások száma egyéb megkötések árán tovább csökkenthetõ.

\par
Mint látható akadályoktól mentes környezetben találhatunk optimális útvonalat, de ennek hátránya, hogy mindig minimális sugarú pályákat feltételez, mely egy valós esetben nem életszerû, illetve a pályák lehetnek igen bonyolultak is. De ha elvetjük az optimalitás igényét, amit egyébként is meg kell tennünk, ha egy globális tervezõ részeként alkalmazzuk a módszert, akkor a lehetséges megoldásokon jelentõs mértékben egyszerûsíthetünk. 

%----------------------------------------------------------------------------
\section{C*CS lokális pályák}
%----------------------------------------------------------------------------
A lokális tervezõk bármely kezdõ- és célkonfiguráció páros esetén megoldást kell nyújtsanak, de megfelelõ koordináta-rendszer választásával egyszerûsíthetünk a számításokon. Tegyük fel hogy egy ilyen választás mellett adódott $q_{I} = (x_{I},y_{I},\theta_{I})$ kezdõ és $q_{G} = (0,0,0)$ célkonfiguráció. Ha eltekintünk a sugár korlátozásától, és feltesszük, hogy $\theta_{I} \neq 0$, akkor könnyen belátható, hogy egy kör és egy egyenes segítségével elérhetõ a célkonfiguráció. Elõször egy érintõ körön elfordulunk a $\tilde{q_{G}} = (\tilde{x_{G}},0,0)$ köztes célkonfigurációba, majd egy egyenes mentén végig haladunk a célig. Az ehhez tartozó kör sugarát a következõ egyenlet segítségével számíthatjuk:
\begin{align}\label{eq:middleRadius}
\rho_{I,\tilde{G}} = \frac{y_{I}}{1 - \cos \theta_{I}}
\end{align}

\par
Ha a kiadódó sugár kisebb mint a minimálisan megengedett ($|\rho_{I,\tilde{G}}| < \rho_{min}$), vagy igaz, hogy $\theta_{I} = 0$, akkor egy egyenes, vagy egy kör segítségével egy köztes kezdõkonfigurációba ($\tilde{q_{I}} = (\tilde{x_{I}},\tilde{y_{I}},\tilde{\theta_{I}})$) kell eljutnunk, ahol biztosított, hogy $\tilde{\theta_{I}} \neq 0$ és, hogy $\rho_{\tilde{I},\tilde{G}} \geq \rho_{min}$. Megjegyzendõ, hogy az elsõ szakasz nem lehet egyenes, ha $\theta_{I} = 0$, $\theta_{I} = \pi$ vagy $|y_{I}| < 2\rho_{min}$. Bizonyított, hogy $\tilde{q_{I}}$ megválasztása végtelen sokféleképpen lehetséges \cite{CCSTopologicalProp}.

\par
Hogy egyszerûsítsük a szakaszok jelölését, a továbbiakban az egyes szakaszokra $S$ és $C$ betûk segítségével hivatkozunk. Az elõzõek alapján, egy konfiguráció párba $SCS$, vagy  $CCS$ segítségével eljuthatunk. Könnyen belátható, hogy ha egy $C$ esetén a sugárral a végtelenbe tartunk, akkor a kiválasztott szakaszunk az egyeneshez tart. Az ilyen speciális köríveket megjelölhetjük egy csillaggal. Innen a módszer neve a $C^{*}CS$.

%----------------------------------------------------------------------------
\section{C*CS approximációs módszer}
%----------------------------------------------------------------------------
Az általunk használt algoritmus egy approximációs módszert alkot, mely egy elõzetes globális pályát rekurzív módon felbont kisebb szakaszokra, majd ezekre próbál illeszteni a fentebb bemutatott C*CS pályát.\footnote{Bár a lokális tervezõ algoritmus neve a C*CS, de a végeredményben kialakult pálya összességében is körök és egyenesek kombinációjából áll, így ez a név ráragadt az approximációs módszerre is. A késõbbiekben, ahol ez félreértésre adhat okot, ott ezt külön tisztázzuk.} A végeredményül elkészült, az algoritmus által visszaadott pálya autószerû robotok számára könnyedén lekövethetõ, mivel elsõdlegesen ezek számára lett kialakítva. Ennek ellenére a megoldást természetesen egy differenciális robot is képes lekövetni, mivel az nem rendelkezik korlátozással a forduló kör sugarára.

%----------------------------------------------------------------------------
\subsection{Globális tervezõ}
%----------------------------------------------------------------------------
Az elõzetes pálya bármilyen globális tervezõ eredménye lehet. Elsõdleges célja egy mankó nyújtása a késõbbi tervezõ számára, a végsõ megoldásnak nem feltétele, hogy az elõzetes pálya akár egyetlen pontját is tartalmazza. Egy lehetséges megoldás az elõzõ fejezetben bemutatott RTR algoritmus használata. Ez az módszer is alkalmas a feladatra, de más módszerek hasznosabbak lehetnek számunkra.

\par
Például ilyen globális tervezõ megoldás a celladekompozíción alapuló algoritmus. Ez a környezetet háromszögekre bontja, majd ezeknek a háromszögeknek az oldalfelezõ pontjait összeköti a szomszédos háromszögekkel. Az így kialakult gráfba beszúrja a kezdõ és célkonfigurációt, majd hozzáveszi az õket körbevevõ háromszög oldalfelezõ pontjait. Az éleket a pontok egymástól való távolságával súlyozzuk, majd ebben a gráfban keresünk egy legrövidebb utat. 
Ennek a megoldásnak kifejezett elõnye, hogy a szabad terület közepén alkot pályát, így ha az autó ezt a pályát követi, akkor bármilyen irányú manõverezésre lesz lehetõsége. További elõnye hogy ez egy kombinatorikus eljárás, így véges idõn belül képes megmondani, hogy létezik-e megoldás. Az eljárás egyik fõ hibája, hogy a háromszögelés miatt, csak sokszögekkel leírható akadályokkal képes dolgozni, és még ebben a formájában nem veszi figyelembe az autó kiterjedését. Ezen könnyen lehet segíteni, ha figyelembe vesszük az oldalfelezõ pontok közötti szakaszok távolságát az akadályoktól, és ha a pálya- és az akadályél túl közel vannak egymáshoz, akkor töröljük az élt a gráfból.

%----------------------------------------------------------------------------
\subsection{Lokális tervezõ}
%----------------------------------------------------------------------------
Ha a globális tervezõ tudott visszaadni megoldást, az algoritmus tovább folytatódik a következõképpen: Az elõzetes pálya két konfigurációját választjuk ki, és a fentebb említett pályákat keresünk köztük. Az eljárás elõször a pálya két végpontja közt keres megoldást, ami egyszerû esetekben akár rögtön megoldásra is vezethet, felgyorsítva az algoritmus mûködését. Ha ez a keresés nem járt sikerrel, akkor az elõzetes pályát megfelezi az algoritmus és az elsõ konfiguráció és az új célkonfiguráció közt keres megoldást. Ezt egészen addig ismétli, míg van köztes konfigurációs pont, ha elfogyott, további pontokat illeszt a pályába.

\par
Az elõzõekben említettük, hogy a C*CS végtelen sok megoldást nyújt. Lokális esetben ez nem elõnyös tulajdonság, de akadályok jelenlétében már elõnyként tekinthetünk rá, mivel így sokkal nagyobb valószínûséggel találhatunk végrehajtható pályát.. Természetesen az összes megoldást így nincs lehetõségünk kipróbálni, így valamilyen mintavételezõ eljárással kell megoldanunk ezt a problémát.

%----------------------------------------------------------------------------
\subsection{ARM}
%----------------------------------------------------------------------------
Az elõzõekben beláttuk, hogy a $\tilde{q_{I}}$ kiválasztásának szabadsága okozza a végtelen sok megoldást. Erre egy példa látható \aref{fig:ARM} ábrán. Ezért algoritmus a folytatásban összegyûjti azokat a konfigurációkat, melyeket a $q_{I}$ konfigurációból ütközés nélkül elérhetünk. Az ilyen konfigurációkat hívjuk az angol megfelelõ rövidítése alapján ARM-nak (Arc Reachable Manifold).

\par
A keresést úgy tesszük meg, hogy a környezetet felosztjuk egységnyi távolságokra, mivel így véges sok lehetõséget kapunk. A kiszámítás ideje természetesen függ a választott távolság egységtõl, és a környezet méretétõl, ami így akár igen hosszúra is nyúlhat. Az eredmények azt mutatják, hogy a teljes algoritmus futásának ez a leghosszabb része, ami nem meglepõ, mivel a körívek kiszámítása komplex mûvelet, és ezt egy adott pont esetén a robot testének minden csúcsára ki kell számoljuk, hogy ütközést tudjunk detektálni. A mûvelet hatékonyságán több módon lehet javítani Például nagyobb távolságegység megválasztásával, vagy ha elõre elkészítünk egy foglaltsági mátrixot, ami megmondja az adott pont akadályon beül van-e, így az ilyen pontokra nem kell a számítást elvégezni. Mivel az ARM egy adott kezdõ-konfigurációhoz tartozik, további javítási lehetõség, ha az approximációs lépésben inkább a célkonfiguráció pontját mozgatjuk, így nem kell újra és újra kiszámolni a köríven elérhetõ sokaságot.

%----------------------------------------------------------------------------
\subsection{CS}
%----------------------------------------------------------------------------
Az algoritmus további részében az ARM-nál kiszámolt elérhetõ köztes konfigurációk és a célkonfiguráció közt kell meghatározni a lehetséges útvonalakat. Mivel a pálya minden esetben egy egyenes szakasszal végzõdik, így a célunk olyan további körök keresése, melyek érintik a köztes konfiguráció és a célkonfiguráció által meghatározott egyeneseket. Ilyen körökbõl egy köztes konfigurációhoz két megoldás is található, mindkét eset megfelelõ megoldást nyújthat számunkra. Azonban figyelembe kell vegyük, hogy a két különbözõ körív mentén való haladás a végeredményben 180$^{\circ}$-os orientáció különbséget okot. Ha a globális pályán egy köztes szakasz számításánál járunk, akkor nem jelent problémát, de az utolsó szakasz esetén el kell vessük az ellenkezõ irányú megoldást, mivel itt már nincs lehetõség megfordulásra.

\par
Ha ezzel megvagyunk nem elegendõ a körívek végrehajthatóságát ellenõriznünk. Ugyan a globális pálya tervezésekor ellenõriztük az egyenes szakaszok akadályoktól való távolságát, így a végrehajthatóságát is, de az érintõ körök keresésekor nem volt feltétel, hogy az érintési pontok ezeken a szakaszokon belül helyezkedjenek el. Ezért ellenõriznünk kell az utolsó, egyenes végrehajthatóságát is.

\par
Végül az így keletkezõ végrehajtható pályák sokasága közül ki kell választanunk egyet. Ezt többféleképpen megtehetjük, talán a legkézenfekvõbb a legrövidebb megoldás kikeresése, és beillesztése az elõzetes pályába. Itt érdemes megemlíteni, hogy a végeredmény akkor fog igazán hasonlítani egy igazi vezetõ által végrehajtott pályára, ha lecsökkentjük a tolatások számát, mivel az emberek nagy többsége nem szeret tolatva közlekedni. Hogy ezt megtehessük, az algoritmus opcionálisan elfogad egy súlytényezõt, mellyel a tolató szakaszok "hosszát" tudjuk megnövelni.

%----------------------------------------------------------------------------
\section{\boldmath{$c\overline{c}S$}}
%----------------------------------------------------------------------------
Ha az elõzõekben látottak nem vezetnek megoldásra, tehát nincs olyan C*CS pálya, mely végrehajtható lenne, akkor egy kisebb szakaszt kell választanunk a globális pályából. Ezt viszont nem tehetjük meg végtelenségig. Az egyik ok, például az, hogy a globális pálya szakaszok nem bonthatók több részre, mert ha ki is választunk egy pontot a szakasz közepérõl, akkor is ugyan arra az egyenesre próbálnánk meg érintõ köröket találni. Persze kereshetünk különbözõ megoldásokat az újabb konfigurációk kiválasztására, de ezek a megoldások önmagukban nem elegendõek. Valahogy biztosítanunk kell azt, hogy az algoritmusunk konvergáljon a megoldás felé, amihez olyan lokális tervezõre van szükségünk, mely teljesíti a topológiai feltételt. Ha ezt biztosítani tudjuk, akkor az algoritmusunk teljes lesz. A teljesség itt azt jelenti, hogy az algoritmus minden olyan esetben megoldással tér vissza, mikor a probléma megoldható.

\par
Olyan esetekben, mikor a globális pályát tovább kellene bontanunk, átváltunk a $c\overline{c}S$ algoritmusra, mely a topológiai feltételt teljesíti \cite{CCSTopologicalProp}. Ez az algoritmus a C*CS algoritmus egy módosított változata, mely csak egy megoldást ad egy konfiguráció párra. Az eljárás lényege, hogy az elsõ két kör sugara megegyezõ, de ellentétes elõjelû, tehát a másik irányba kell forgassuk a kormányt a váltáskor. A komplementer jelölés jelzi az elõjel változását. Ahogy \aref{fig:ccS} látható, ha $q_{I}$ túl közel van a $q_{G}$ egyeneséhez, akkor a körök egymás mellett elcsúsznak, és két megoldást is adnak.

\par
Bár a $c\overline{c}S$ egy megoldást ad, a végrehajtásakor több lehetséges megoldást is "eldob". A módszer implementációját úgy készítettük el, hogy minden ilyen megoldást ellenõrizzen, ha esetleg a legrövidebb nem lenne végrehajtható. Jogosan felmerülhet a kérdés, hogy ha ez az algoritmus bármilyen konfigurációs párra nyújt megoldást, akkor miért nem ezt használjuk a C*CS helyett? A $c\overline{c}S$ csak egy lokális tervezõ, így nem veszi figyelembe az akadályokat, hibába teljesíti a topológiai feltételt, ez csak annyit jelent, hogy ha közelítjük a konfigurációkat egymáshoz, a visszaadott megoldás hossza is csökken. A másik indokunk, hogy az eljárás minden esetben két azonos sugarú körrel tér vissza. Ez a valóságot se közelíti jól, hiszen nincs olyan sofõr aki így vezetne minden esetben.

%----------------------------------------------------------------------------
\section{Eredmények}
%----------------------------------------------------------------------------
A tervezõ algoritmus futása közben nagy mennyiségû lebegõpontos számítást végez, de ezen felül viszonylag nagy memóriaigényû is, és sok iterációs szakasza van. Az algoritmus egy implementált változata rendelkezésre állt \texttt{MatLAB script} formátumban, de ez elsõdlegesen demonstrációs célt szolgált. Ettõl a nyelvtõl azt várnánk, hogy a lebegõpontos számításokat gyorsan képes elvégezni, de a feladatot rendkívül lassan hajtotta végre. Ennek elsõdleges oka valószínûleg a sok iteráció. Az ilyen algoritmusokra nem ez a legalkalmasabb nyelv, ezért is merült fel elsõdlegesen egy gépközeli nyelv használata. A legnagyobb tapasztalatunk a C++ nyelvvel kapcsolatban volt, és grafikus számítások során is ezt a nyelvet szokták használni a hatékonysága miatt. Ezek mellett további fontos érv volt, hogy az algoritmust egy mûködõ mobil roboton is ki tudjunk próbálni, ott is ésszerû idõn belül megoldást adjon.

\par
A fejlesztés során igen fontos volt az objektum-orientált szemléletmód, mivel így biztosítható a legjobban a modularitás, és a késõbbi egyszerû fejlesztés, módosítás. Az implementálás során egyéb elõnyös tulajdonságát is ki tudtuk használni, ezek közül a legjelentõsebb az újrafelhasználhatóság volt. Az implementálás elõrehaladtával a a fejlesztés sebessége is nõtt, mivel az elõzõleg elkészített kódrészleteket egyszerûen újra tudtuk használni.

\par
Pontos méréseket nem végeztünk se a MatLAB implementációval kapcsolatban, se a késõbbiekben elkészült C++ kóddal se, de ezek összehasonlíthatósága egyébként is igen kérdéses, mivel különbözõ pályák esetén különbözõ részek futása válik szûk keresztmetszetté, és a két programnyelv más-más esetben lehet hatékony. Viszont végeredményben nagyságrendileg százszoros gyorsulást sikerült elérnünk, és a legbonyolultabb környezetben is egy másodpercen belül sikerült megoldást találnia az algoritmusnak\footnote{Intel Core 2 Duo E8400 @ 3.0Ghz, 4Gb RAM}, így valószínû egy kisebb teljesítményû beágyazott számítógépen is elfogadható idõn belül végez.

\par
A fejlesztés során odafigyeltünk, hogy hol lehetne gyorsítani, módosítani a mûködésen. Ahol ez egyszerûen megvalósítható volt, ott ezeket el is végeztük, de maradtak további fejlesztési lehetõségek is a programban. A leggyakoribb esetben az ARM számítása veszi el a pályatervezés során a legtöbb idõt. Mivel az algoritmus az egész területet mintavételezi és kiszámítja minden pontra az oda tartó körívet ez egy igen idõigényes részfeladat. Könnyen belátható, hogy egy olyan pálya esetén, ahol például egy szûk folyosón kell áthaladni, ott az akadályok túloldala nem elérhetõ ütközés nélkül. Jó ötlet lenne csak azt az oldalt figyelembe venni, ahol a robot van, de annak meghatározás, hogy hol a határ, amit már nem kell ellenõrizni, nem egy egzakt feladat.

\par
A globális tervezõ által tervezett pálya, csak segítséget nyújt a lokális tervezõ számára, így annak alakja nagyon kis mértékben van hatással a végleges pályára. Néhány speciális esetben mégis látható ez a különbség, mint például \aref{fig:globalisPalyaHatasa} ábrán is megfigyelhetõ különbséget eredményez a háromszögelõ algoritmus módosítása.













