%----------------------------------------------------------------------------
\chapter{Az RTR algoritmus}
%----------------------------------------------------------------------------
Az RTR (Rotate-Translate-Rotate) algoritmust Kiss Domokos dolgozta ki \cite{DomiRTR}. A mi feladatunk az algoritmus implementálása volt C++ nyelven, majd az algoritmus tesztelése szimulációs környezetben és valós roboton.

\par
Az algoritmus az irodalomból gyakran használt RRT algoritmuson alapszik, ezért ennek a bemutatásával kezdjük a fejezetet.

%----------------------------------------------------------------------------
\section{RRT algoritmus}
%----------------------------------------------------------------------------
Az RRT (Rapidly Exploring Random Trees) algoritmus lényege, hogy a kezdeti konfigurációból egy fát építünk a szabadon bejárható térben \cite{LaValle}. A fa terjesztését úgy irányítjuk, hogy a kívánt cél konfiguráció felé tartson. Ezután az utat a kezdeti konfigurációból a cél konfigurációba már könnyedén megkaphatjuk a fában. Létezik olyan változata az RRT algoritmusnak, ahol nemcsak a kezdeti konfigurációból építünk fát, hanem a cél konfigurációból vagy akár több köztes pontból is.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/RRT.png}
\caption{Az RRT algoritmus három különbözõ iterációnál.} 
\label{fig:RRT}
\end{figure}

\par
A fa építés úgy kezdõdik, hogy véletlen konfigurációkat veszünk a környezetbõl ($q_{rand}$). Ezt hívják mintavételezési szakasznak. Ezután meghatározzuk, hogy a fában melyik konfiguráció van a legközelebb a mintavételezett konfigurációhoz $q_{near}$. Ez a csomópont-választó szakasz. Elõfordulhat, hogy nemcsak a fa csúcspontjában található konfigurációkat adjuk vissza, mint $q_{near}$, hanem a fa csúcspontjai közötti élek egy köztes konfigurációját.

\par
A következõ lépésben megpróbáljuk a $q_{rand}$ és a $q_{near}$ konfigurációkat interpolálással összekötni (összekötõ szakasz). Itt több variációja is létezik az RRT-nek. Elõfordul, hogy csak egy bizonyos fix $\Delta q$ értékkel közelítünk $q_{rand}$ felé $q_{near}$ konfigurációból. A másik esetben addig terjesztjük a fát amíg el nem érjük $q_rand$ konfigurációt vagy amíg nem ütközik a robot. Ebben az esetben a kapott konfiguráció a legmesszebb található ütközés mentes konfiguráció lesz $q_rand$ irányában. Az újonnan kapott konfigurációt végül hozzáadjuk a fához.

\par
Anholonom rendszerek esetén is használható az RRT eljárás. Ekkor az összekötésnél egyszerû interpolációt nem lehet alkalmazni, mert az azt feltételezné, hogy a robot minden irányba szabadon képes mozogni. Ehelyett az összeköttetést egy lokális tervezõ segítségével kell  megoldani vagy egyszerûbb esetben itt is használható az a módszer, hogy csak egy adott $\Delta q$ értékkel közelítünk $q_{rand}$ irányába. Ehhez megfelelõ beavatkozó jelet kell választanunk, amit $\Delta t$ ideig alkalmazva elérhetõ $\Delta q$ állapotváltozás.

%----------------------------------------------------------------------------
\section{RTR algoritmus}
%----------------------------------------------------------------------------
Differenciális robot esetében is használható ez elõbb említett módszer, de ekkor a fa csúcspontjai között görbék lesznek. Ez nehézséget okozhat, ha olyan csomópont-választó eljárást alkalmazunk, ami köztes konfigurációt ad vissza. Természetesen alkalmazhatjuk azt az eljárást, hogy csak az élek végpontjait választjuk ki. Ehhez kis távolságú élek szükségesek, ami növeli a fa csomópontjainak számát és ezzel összefüggésben a csomópont kiválasztások számát is.

\par
Differenciális robotnál is alkalmazhatunk lokális tervezõt két konfiguráció közti állapotváltozásra. A legegyszerûbb lokális tervezõ három lépésbõl áll:

\begin{itemize}
\item Egy helyben fordulás a kívánt konfiguráció irányába (R).
\item Mozgás egyenes pályán a cél pozícióba (T).
\item Egy helyben fordulás a cél konfiguráció irányába (R).
\end{itemize}

\par
Ennek a tervezõnek az az elõnye, hogy fa élei egyenes pályák lesznek, így egyszerûn tudjuk meghatározni a köztes konfigurációkat is és egzakt módon leírhatjuk a mozgásokat, nem kell mintavételezést alkalmaznunk.

\par
A jelenleg ismertetett módon alkalmazva az algoritmust szûk folyosók esetében igen nehezen találna megoldást az eljárás. Abban az esetben is ha mind a kezdeti-, mind a célkonfigurációból növesztünk egy-egy fát. A problémát az okozza, hogy a összeköttetés fázisa gyakran nem ad eredményt és így a fák nem nõnek megfelelõen. Ennek az az oka, hogy a lokális tervezõ esetében, fal vagy egyéb akadályok közelében az elsõ egy helyben fordulásnál már ütközne a robot. Mivel az összeköttetés fázisa addig tart, amíg nem érjük el $q_{rand}$-ot vagy amíg nem ütközik a robot, így a fa további terjesztése nélkül választunk új $q_{rand}$ értéket. A lokális tervezõ második lépése eredményezné a fa tényleges terjesztését.

\par
Az RTR algoritmus felhasználva az RRT eljárás elõnyös tulajdonságait igyekszik az elõbbi problémára egy lehetséges megoldást bemutatni. Mind a kezdeti, mind a célkonfigurációból növeszt egy-egy fát, összeköttetõ fázisban a fent ismertetett Rotate-Translate-Rotate lokális tervezõt alkalmazza. Az RRT eljárás mind a három fázisa módosításra kerül az RTR tervezõ esetében.

Az RTR algoritmusnál alkalmazott fa struktúrában, az RRT-hez hasonlóan a csomópontokban konfigurációk találhatóak, az élek pedig transzlációs mozgást (TCI - Translation Configuration Interval) vagy egy helyben fordulást írnak le (Rotational Configuration Interval). Fontos megjegyezni, hogy mindkét éltípust egzakt módon írjuk le.

%----------------------------------------------------------------------------
\subsection{Mintavételezés}
%----------------------------------------------------------------------------

\par
A mintavételezés fázisában különbséget jelent az eredeti RRT algoritmushoz képest, hogy nálunk a $q_{rand}$-nak megfelelõ véletlen minta nem egy konfiguráció lesz, hanem egy pozíció a térben (GP - Guide Point). Ezt a pozíciót tekinthetjük egy folytonos, egy dimenziós konfigurációs listának, amelynek bármelyik eleme megfelelõ cél konfigurációnak.

\par
A mintavételezést kiegészíthetjük a pálya háromszög cellafelbontásából kapott mintákkal. Ezek a minták az akadályoktól távolabb találhatóak és szûk folyosók esetén is segítenek terjeszteni a fákat.

%----------------------------------------------------------------------------
\subsection{Csomópont-kiválasztás}
%----------------------------------------------------------------------------
Mivel a mintavételezésnél pozíciót használunk nem pedig konfigurációt, így a csomópont kiválasztás egyszerûbb lesz. Az eljárás lényege, hogy az adott GP esetén végigmegyünk a fa élein és meghatározzuk a legkisebb távolságát a GP és az adott él között. TCI él esetében ez távolságot jelent, RCI esetében pedig szögtávolságot. Így minden egyes élnél kapunk egy konfigurációt, amely esetében a távolság a GP-tõl minimális. A kapott konfigurációk közül azt választjuk amelynél legkisebb a távolság a GP-hez képest, ha így több megoldást is kapunk, akkor pedig azt a konfigurációt választjuk, amelynél a szögtávolság a legkisebb. Így egyértelmûen meghatároztuk $q_{near}$-t.

\par
Egy adott TCI és GP esetén a legkisebb távolsághoz tartozó konfigurációt a következõképpen határozzuk meg. Kiszámoljuk a GP vetületét a TCI-t alkotó egyenesre, ezután meghatározzuk, hogy a vetület a TCI-n, mint szakaszon belül található-e. Ha a szakaszon belül található, akkor egy köztes konfiguráció van a legközelebb a ponthoz és a köztes konfiguráció pozíciója a vetület, orientációja pedig a TCI orientációja. Ha a szakaszon kívül található a vetület, akkor a TCI közelebbi konfigurációja lesz a legkisebb távolságú konfiguráció.

\begin{figure}[H]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/rci_gp.png}
\caption{Csomópont-kiválasztás RCI esetén. A bal oldali ábra esetén köztes konfigurációt kapunk, míg a jobb oldali ábrán nem.} 
\label{fig:rci_gp}
\end{figure}

\par
RCI esetén a legkisebb (szög)távolságú konfiguráció kiválasztása \aref{fig:rci_gp}. ábrán látható. Elõször kiszámoljuk a GP és az RCI pozíciójának irányát. Ha a kapott irány az RCI (szög)tartományába beleesik, akkor köztes konfigurációról van szó (bal oldali ábra) és ekkor a legközelebbi konfiguráció az RCI pozíciója és az elõbb kiszámolt orientáció lesz. Abban az esetben mikor a kapott irány nem esik bele az RCI tartományába, akkor az RCI irányban közelebbi konfigurációt választjuk (jobb oldali ábra).

%----------------------------------------------------------------------------
\subsection{Kiterjesztés}
%----------------------------------------------------------------------------
Az RTR algoritmus ezen fázisa különbözik leginkább az RRT algoritmustól. A kiterjesztés során RT primitíveket használunk a teljes RTR lokális tervezõ helyett


%----------------------------------------------------------------------------
\subsection{Útvonal meghatározása, optimalizálás - 1 oldal}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\section{Eredmények - 3 oldal}
%----------------------------------------------------------------------------


